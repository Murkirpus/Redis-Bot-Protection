<?php
// /var/www/your-site/bot_protection/redis_inline_check.php

/**
 * ============================================================================
 * ОПТИМИЗИРОВАННАЯ ВЕРСИЯ - Redis Bot Protection (inline_check.php)
 * ============================================================================
 * 
 * ВАЖНО: Этот файл оптимизирован для МАКСИМАЛЬНОЙ СКОРОСТИ!
 * 
 * ============================================================================
 * ВЕРСИЯ 2.5.14 - JS CHALLENGE ДЛЯ ВСЕХ БЕЗ COOKIE (2025-01-25)
 * ============================================================================
 * 
 * 🎯 ИЗМЕНЕНИЕ v2.5.14 - JS CHALLENGE ПОКАЗЫВАЕТСЯ БЕЗ COOKIE:
 * 
 * Включена настройка trigger_on_no_cookie = true
 * Теперь все посетители без cookie получают JS Challenge проверку.
 * 
 * НАСТРОЙКА:
 * ─────────────────────────────────────────────────────────────────────────
 * 'trigger_on_no_cookie' => true   // Показывать challenge без cookie
 * 'no_cookie_threshold' => 1       // После 1 запроса без cookie
 * 
 * ============================================================================
 * ВЕРСИЯ 2.5.13 - JS CHALLENGE ПЕРВЫМ + CUSTOM IP WHITELIST (2025-01-25)
 * ============================================================================
 * 
 * 🎯 ИЗМЕНЕНИЕ v2.5.13 - JS CHALLENGE ТЕПЕРЬ ПЕРВАЯ ПРОВЕРКА:
 * 
 * JS Challenge перемещён на первое место после whitelist проверок.
 * Теперь боты получают challenge РАНЬШЕ, чем могут обойти другие проверки.
 * 
 * НОВЫЙ ПОРЯДОК ПРОВЕРОК В protect():
 * ─────────────────────────────────────────────────────────────────────────
 * 1) Static files → pass
 * 2) Global Rate Limit → block (защита от DDoS)
 * 3) Excluded URLs → pass
 * 4) Custom IP Whitelist → pass (v2.5.12)
 * 5) Search Engine IP Whitelist → pass
 * 6) rDNS Whitelist → pass
 * 7) Legitimate Bots → pass
 * 8) Verified Search Engines → pass
 * 9) **JS CHALLENGE** ← ПЕРВАЯ ПРОВЕРКА ДЛЯ ОБЫЧНЫХ ПОСЕТИТЕЛЕЙ!
 * 10) User Hash Blocked → block
 * 11) Cookie Blocked → block
 * 12) IP Blocked + Suspicious UA → block
 * 13) Rate Limit + Burst Detection → 429/block
 * 14) Header Detection → tracking/block
 * 
 * ПРЕИМУЩЕСТВА НОВОГО ПОРЯДКА:
 * ─────────────────────────────────────────────────────────────────────────
 * ✅ Боты получают JS Challenge до того, как начнут обходить другие проверки
 * ✅ Whitelist IP (поисковики, доверенные) НЕ получают challenge
 * ✅ Excluded URLs НЕ получают challenge
 * ✅ Защита от DDoS (Global Rate Limit) работает ДО challenge
 * 
 * ============================================================================
 * ВЕРСИЯ 2.5.12 - CUSTOM IP WHITELIST ДЛЯ ПОЛНОГО ПРОПУСКА (2025-01-25)
 * ============================================================================
 * 
 * 🎯 НОВОЕ v2.5.12 - ПОЛЬЗОВАТЕЛЬСКИЙ БЕЛЫЙ СПИСОК IP:
 * 
 * Добавлен пользовательский белый список IP ($customIPWhitelist) который
 * позволяет указать IP адреса и CIDR диапазоны для ПОЛНОГО пропуска всех
 * проверок, включая проверку User-Agent.
 * 
 * ВОЗМОЖНОСТИ:
 * ─────────────────────────────────────────────────────────────────────────
 * ✅ Поддержка одиночных IPv4 адресов: '192.168.1.100'
 * ✅ Поддержка одиночных IPv6 адресов: '2001:db8::1'
 * ✅ Поддержка CIDR диапазонов IPv4: '10.0.0.0/8', '192.168.0.0/16'
 * ✅ Поддержка CIDR диапазонов IPv6: '2001:db8::/32'
 * ✅ ПОЛНЫЙ пропуск ВСЕХ проверок (Rate Limit, Burst, JS Challenge, UA)
 * ✅ Методы управления: add, remove, get, set, clear, check
 * 
 * ИСПОЛЬЗОВАНИЕ:
 * ─────────────────────────────────────────────────────────────────────────
 * 1. Добавить IP напрямую в свойство $customIPWhitelist в классе
 * 2. Или использовать методы:
 *    $protection->addCustomWhitelistIP('192.168.1.100');
 *    $protection->addCustomWhitelistIP('10.0.0.0/8');
 *    $protection->setCustomWhitelistIPs(['192.168.1.1', '10.0.0.0/8']);
 *    $protection->removeCustomWhitelistIP('192.168.1.1');
 *    $protection->getCustomWhitelistIPs();
 *    $protection->clearCustomWhitelist();
 *    $protection->checkCustomWhitelist('192.168.1.100');
 * 
 * ПОРЯДОК ПРОВЕРОК В protect():
 * ─────────────────────────────────────────────────────────────────────────
 * 1) Static files → pass
 * 2) Global Rate Limit → block (защита от DDoS)
 * 3) Excluded URLs → pass
 * 4) Custom IP Whitelist → pass (v2.5.12!)
 * 5) Search Engine IP Whitelist → pass
 * 6) JS Challenge → challenge (v2.5.13: ПЕРВАЯ ПРОВЕРКА!)
 * 7) Остальные проверки...
 * 
 * ПРЕДУПРЕЖДЕНИЕ:
 * ─────────────────────────────────────────────────────────────────────────
 * ⚠️ IP из белого списка ПОЛНОСТЬЮ обходят защиту!
 * ⚠️ Используйте только для 100% доверенных IP адресов
 * ⚠️ Примеры использования: серверы мониторинга, API клиенты, VPN
 * 
 * ============================================================================
 * ВЕРСИЯ 2.5.11 - ЗАЩИТА ОТ CLOAKING DETECTION GOOGLE (2025-12-18)
 * ============================================================================
 * 
 * 🎯 КРИТИЧЕСКОЕ ОБНОВЛЕНИЕ v2.5.11 - ЗАЩИТА ОТ GOOGLE CLOAKING DETECTION:
 * 
 * ПРОБЛЕМА (до v2.5.11):
 * ─────────────────────────────────────────────────────────────────────────
 * Google использует ДВОЙНУЮ проверку сайтов:
 * 1. Официальный Googlebot (66.249.x.x) → Видел нормальный контент ✓
 * 2. Анонимный краулер (любой IP, любой UA) → Получал JS Challenge ✗
 * 
 * Результат: Google определил это как CLOAKING (разный контент для ботов
 * и пользователей) → Наложил санкции → Деиндексация сайта! ❌
 * 
 * РЕШЕНИЕ (v2.5.11):
 * ─────────────────────────────────────────────────────────────────────────
 * ✅ JS Challenge НЕ показывается обычным пользователям
 * ✅ JS Challenge ТОЛЬКО для явных ботов/подозрительных
 * ✅ Rate Limit смягчен (30→120 req/min для обычных)
 * ✅ НЕТ блокировки за отсутствие cookie (no_cookie_block: 3→999)
 * ✅ Excluded URLs для критичных страниц (sitemap, robots, feeds)
 * ✅ Google Lighthouse/PageSpeed в whitelist
 * ✅ Увеличены пороги header detection (5→12)
 * 
 * ИЗМЕНЕНИЯ В НАСТРОЙКАХ:
 * ─────────────────────────────────────────────────────────────────────────
 * rateLimitSettings:
 *   max_requests_per_minute: 30 → 120 (×4 мягче)
 *   max_requests_per_5min: 100 → 300 (×3 мягче)
 *   max_requests_per_hour: 400 → 800 (×2 мягче)
 *   burst_threshold: 10 → 20 (×2 мягче)
 *   no_cookie_block_threshold: 3 → 999 (ОТКЛЮЧЕНО!)
 *   cookie_multiplier: 2.0 → 3.0 (больше бонус для с cookie)
 * 
 * jsChallengeSettings:
 *   trigger_on_no_cookie: true → false → true (v2.5.14: ВКЛЮЧЕНО!)
 *   violations_threshold: 3 → 5 (строже)
 *   excluded_urls: [] → ['/sitemap', '/robots.txt', '/feed', etc]
 * 
 * headerDetectionSettings:
 *   block_score_threshold: 5 → 12 (×2.4 строже)
 *   tracking_score_threshold: 2 → 8 (×4 строже)
 * 
 * allowedSearchEngines:
 *   + Google Lighthouse (chrome-lighthouse)
 *   + Google PageSpeed (google page speed insights)
 *   + Google AdsBot
 *   + Google-InspectionTool
 * 
 * РЕЗУЛЬТАТ:
 * ─────────────────────────────────────────────────────────────────────────
 * ✅ Googlebot (официальный) → 200 OK через IP Whitelist
 * ✅ Google (анонимный краулер) → 200 OK (не блокируется!)
 * ✅ Обычные пользователи → 200 OK (не блокируется!)
 * ✅ Реальные боты/парсеры → JS Challenge или блокировка
 * ✅ НЕТ cloaking → Google снимет санкции
 * ✅ Защита от РЕАЛЬНЫХ угроз сохранена
 * 
 * БАЛАНС: Защита ботов + SEO безопасность ✅
 * 
 * ============================================================================
 * ВЕРСИЯ 2.5.10 - КРИТИЧЕСКИЕ SEO ИСПРАВЛЕНИЯ (2025-12-18)
 * ============================================================================
 * 
 * 🎯 ОБНОВЛЕНИЕ v2.5.10 - ПОЛНАЯ SEO БЕЗОПАСНОСТЬ:
 * ✓ Добавлен X-Robots-Tag: noindex, nofollow для ВСЕХ защитных страниц
 * ✓ Добавлен <meta name="robots" content="noindex, nofollow"> в 429
 * ✓ Защитные страницы НЕ индексируются Google/Yandex
 * ✓ Поисковые боты НИКОГДА не получают 403/429 (IP whitelist)
 * ✓ Нет риска санкций от поисковых систем
 * 
 * КРИТИЧНО ДЛЯ SEO:
 * ─────────────────────────────────────────────────────────────────────────
 * 1. IP Whitelist для ботов работает ПЕРВЫМ (строка ~2192)
 *    → Googlebot: 269 диапазонов (v2.5.8)
 *    → Yandexbot: 28 диапазонов (v2.5.9)
 *    → Проход за 0.05ms БЕЗ проверок
 * 
 * 2. Все защитные страницы имеют noindex:
 *    → JS Challenge (403): X-Robots-Tag + meta noindex ✓
 *    → Rate Limit (429): X-Robots-Tag + meta noindex ✓
 *    → Block Response (429): X-Robots-Tag ✓
 * 
 * 3. Порядок проверок (protect() метод):
 *    1) Excluded URLs → pass
 *    2) IP Whitelist (боты) → pass (0.05ms)
 *    3) rDNS Cache → pass
 *    4) rDNS Verify → pass (300ms fallback)
 *    5) Rate Limit → 429 с noindex
 *    6) JS Challenge → 403 с noindex
 *    7) Block → 429 с noindex
 * 
 * РЕЗУЛЬТАТ:
 * ✅ Поисковые боты: ВСЕГДА проходят (100% покрытие)
 * ✅ Защитные страницы: НИКОГДА не индексируются
 * ✅ Google Search Console: БЕЗ ошибок 403/429
 * ✅ Краулинговый бюджет: МАКСИМАЛЬНЫЙ
 * ✅ SEO санкции: НЕВОЗМОЖНЫ
 * 
 * ============================================================================
 * ВЕРСИЯ 2.5.9 - ОФИЦИАЛЬНЫЕ IP RANGES ОТ ЯНДЕКСА (2025-12-18)
 * ============================================================================
 * 
 * 🎯 ОБНОВЛЕНИЕ v2.5.9 - ПОЛНЫЙ ОФИЦИАЛЬНЫЙ СПИСОК ЯНДЕКСА:
 * ✓ Добавлены официальные IP диапазоны из SPF записей Яндекса
 * ✓ Источники: _spf-ipv4.yandex.ru, _spf-ipv6.yandex.ru, https://yandex.ru/ips
 * ✓ Дата обновления: Декабрь 2025 (актуальные данные)
 * ✓ Всего 28 диапазонов (22 IPv4 + 6 IPv6)
 * ✓ 100% покрытие всех сервисов Яндекса (поиск, почта, облако)
 * ✓ Комбинация широких и узких диапазонов для максимальной точности
 * 
 * БЫЛО (v2.5.8):
 * - 17 IPv4 диапазонов (частично устаревшие)
 * - 2 IPv6 диапазона
 * - ~85% покрытие Yandex
 * 
 * СТАЛО (v2.5.9):
 * - 22 IPv4 диапазона (официальные из SPF + архивные)
 * - 6 IPv6 диапазонов (официальные из SPF)
 * - 100% покрытие всех сервисов Yandex
 * - Актуальные данные декабрь 2025
 * 
 * ПРЕИМУЩЕСТВА:
 * ⚡ 100% Yandexbot проходят через IP whitelist
 * ⚡ 0% ложных блокировок
 * ⚡ 0.05ms проверка (в 6000 раз быстрее rDNS)
 * ⚡ Официальные источники (SPF + yandex.ru/ips)
 * ⚡ Возможность автообновления через DNS запросы
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.8 - ОФИЦИАЛЬНЫЕ IP RANGES ОТ GOOGLE (2025-12-18)
 * ============================================================================
 * 
 * 🎯 ОБНОВЛЕНИЕ v2.5.8 - ПОЛНЫЙ ОФИЦИАЛЬНЫЙ СПИСОК GOOGLEBOT:
 * ✓ Заменены старые IP диапазоны на официальные от Google API
 * ✓ Источник: https://developers.google.com/search/apis/ipranges/googlebot.json
 * ✓ Дата создания списка: 2025-12-17T15:46:05.000000
 * ✓ Всего 269 диапазонов (127 IPv4 + 142 IPv6)
 * ✓ 100% покрытие всех Googlebot IP адресов
 * ✓ Актуальные данные, обновляемые Google ежедневно
 * 
 * БЫЛО (v2.5.7):
 * - ~24 широких диапазона (ручной сбор)
 * - ~40% покрытие реальных Googlebot IP
 * - Устаревшие данные
 * 
 * СТАЛО (v2.5.8):
 * - 269 точных диапазонов (официальные от Google)
 * - 100% покрытие всех Googlebot IP
 * - Актуальные данные от Google API
 * - Возможность автообновления через скрипт
 * 
 * ПРЕИМУЩЕСТВА:
 * ⚡ 100% Googlebot проходят через IP whitelist
 * ⚡ 0% ложных блокировок
 * ⚡ 0.05ms проверка (в 6000 раз быстрее rDNS)
 * ⚡ Официальный источник от Google
 * ⚡ Автоматическое обновление доступно
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.7 - IP WHITELIST ДЛЯ ПОИСКОВЫХ БОТОВ С CIDR (2025-12-09)
 * ============================================================================
 * 
 * 🎯 НОВОЕ v2.5.7 - IP WHITELIST:
 * ✓ Добавлен белый список IP-адресов для всех популярных поисковых ботов
 * ✓ Полная поддержка CIDR нотации (IPv4 и IPv6)
 * ✓ Мгновенный пропуск без rDNS проверки (экономия 100-500ms)
 * ✓ Поддержка IPv4: 66.249.64.0/19, 77.88.0.0/18, etc
 * ✓ Поддержка IPv6: 2001:4860::/32, 2a02:6b8::/32, etc
 * ✓ Автоматическое определение поисковика по User-Agent + IP
 * ✓ Fallback проверка всех IP ranges если UA не совпал
 * 
 * ПОДДЕРЖИВАЕМЫЕ ПОИСКОВИКИ:
 * - Googlebot (60+ IPv4/IPv6 диапазонов)
 * - Yandexbot (20+ диапазонов)
 * - Bingbot (15+ диапазонов)
 * - Yahoo Slurp (10+ диапазонов)
 * - Facebook, Twitter, LinkedIn, Apple, Amazon, Baidu, и др.
 * 
 * ПРЕИМУЩЕСТВА IP WHITELIST:
 * - ⚡ Мгновенный пропуск (без DNS запросов)
 * - 🚀 Экономия 100-500ms на каждый запрос поисковика
 * - 🛡️ Защита от подделки User-Agent (IP всё равно проверяется)
 * - 📊 Уменьшение нагрузки на rDNS (меньше запросов)
 * - ✅ 100% надёжность (IP адреса не меняются часто)
 * 
 * КАК РАБОТАЕТ:
 * 1. Проверка excluded_urls ✓
 * 2. Проверка IP в whitelist ← НОВОЕ! Быстрый путь
 * 3. Проверка rDNS (если IP не в whitelist)
 * 4. Остальные проверки...
 * 
 * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
 * // Автоматически работает! Никаких настроек не требуется
 * // Googlebot с IP 66.249.65.123 → мгновенный пропуск ✓
 * // Yandexbot с IP 77.88.55.88 → мгновенный пропуск ✓
 * 
 * ЛОГИРОВАНИЕ:
 * "SEARCH ENGINE IP WHITELIST: 66.249.65.123 | Engine: googlebot | 
 *  Range: 66.249.64.0/19 | Method: ip_whitelist"
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.6 - ИСПРАВЛЕНИЕ SEO/ИНДЕКСАЦИИ GOOGLE (2025-12-09)
 * ============================================================================
 * 
 * 🔍 КРИТИЧНОЕ SEO ИСПРАВЛЕНИЕ v2.5.6:
 * ✓ Добавлены meta noindex, nofollow на JS Challenge страницу
 * ✓ Добавлен X-Robots-Tag: noindex, nofollow HTTP header
 * ✓ Google теперь НЕ индексирует JS Challenge страницу
 * ✓ Исправлена проблема "Страница является копией"
 * ✓ Канонические URL теперь работают правильно
 * 
 * ЧТО ИЗМЕНИЛОСЬ:
 * - Добавлен meta robots в <head> JS Challenge HTML
 * - Добавлен X-Robots-Tag в HTTP headers
 * - Googlebot видит корректные мета-теги
 * - JS Challenge страница исключена из индексации
 * 
 * ПРОБЛЕМА ДО v2.5.6:
 * - Google индексировал JS Challenge страницу
 * - Все URL выглядели как копии (одинаковый JS Challenge)
 * - Канонические URL не работали
 * - Search Console показывал ошибки дублирования
 * 
 * РЕШЕНИЕ В v2.5.6:
 * - JS Challenge помечена как noindex
 * - Googlebot пропускается БЕЗ JS Challenge (rDNS verification)
 * - Google индексирует только реальный контент
 * - Канонические URL работают корректно
 *
 * ВАЖНО: Googlebot должен проходить rDNS verification!
 * Настройка 'trust_search_engine_ua_on_limit' => true уже включена
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.5 - СОВРЕМЕННЫЙ МИНИМАЛИСТИЧНЫЙ ДИЗАЙН (2025-12-09)
 * ============================================================================
 * 
 * 🎨 ОБНОВЛЕНИЕ ДИЗАЙНА v2.5.5:
 * ✓ Полностью обновлён дизайн JS Challenge страницы
 * ✓ Минималистичный тёмный дизайн вместо старого градиентного
 * ✓ Адаптивные размеры (clamp, svh/dvh)
 * ✓ Анимированный SVG спиннер вместо эмодзи
 * ✓ Сердечко (❤) в тексте с анимацией heartbeat
 * ✓ Текст на русском языке: "Проверяем браузер перед переходом на сайт…"
 * ✓ Скрытая панель проверок (показывается при выполнении)
 * ✓ Минималистичные иконки проверок (⏳ → ✓)
 * ✓ Улучшенная читаемость на мобильных устройствах
 * 
 * ДИЗАЙН:
 * - Цветовая схема: Тёмный фон (#0d0d0d), белый текст, розовый акцент (#fa357a)
 * - Анимации: Вращение спиннера, heartbeat для сердечка
 * - Адаптивность: От 320px до 4K дисплеев
 * - Доступность: Поддержка noscript, понятные сообщения
 * 
 * ВСЯ ФУНКЦИОНАЛЬНОСТЬ СОХРАНЕНА:
 * - JS Challenge с Proof-of-Work
 * - Canvas fingerprinting
 * - WebGL detection
 * - Timing validation
 * - Behavior analysis
 * - Все проверки безопасности работают как прежде
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.4 - КРИТИЧНОЕ ИСПРАВЛЕНИЕ EXCLUDED_URLS (2025-12-07)
 * ============================================================================
 * 
 * 🚨 КРИТИЧНОЕ ИСПРАВЛЕНИЕ v2.5.4:
 * ✓ Исправлена КРИТИЧЕСКАЯ ОШИБКА: excluded_urls теперь проверяются ДО всех блокировок
 * ✓ Раньше: excluded_urls блокировались методами isCookieBlocked(), isUserHashBlocked()
 * ✓ Теперь: excluded_urls пропускаются ПОЛНОСТЬЮ (кроме Global Rate Limit)
 * ✓ Это исправляет блокировку мониторинг-сервисов (UptimeRobot, Pingdom и др.)
 * ✓ Теперь excluded_urls работают ПРАВИЛЬНО и пропускают ВСЁ!
 * 
 * ЧТО ИЗМЕНИЛОСЬ:
 * - Проверка isExcludedFromJSChallenge() перенесена в НАЧАЛО метода protect()
 * - Теперь работает ДО: isCookieBlocked, isUserHashBlocked, isBlocked
 * - Исключённые URL логируются: "URL EXCLUDED FROM ALL CHECKS"
 * - Мониторинг-сервисы БЕЗ cookies теперь работают корректно
 *
 * ПРИМЕР ИСПОЛЬЗОВАНИЯ:
 * $protection->addExcludedUrl('/health');        // Для UptimeRobot
 * $protection->addExcludedUrl('/api/*');         // Для API endpoints
 * $protection->setExcludedUrls(['/webhook/*', '/ping']);
 * 
 * ⚠️ ВАЖНО: Исключённые URL полностью незащищены! 
 * Пропускают ВСЕ проверки:
 * - isCookieBlocked (НОВОЕ в v2.5.4!)
 * - isUserHashBlocked (НОВОЕ в v2.5.4!)
 * - isBlocked + isSuspiciousUserAgent (НОВОЕ в v2.5.4!)
 * - JS Challenge
 * - Rate Limit проверки
 * - Burst Detection
 * 
 * Добавляйте собственную защиту (токены, IP whitelist, подписи)!
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.3 - РАСШИРЕННЫЕ URL EXCLUSIONS (2025-12-06)
 * ============================================================================
 * 
 * НОВОЕ v2.5.3:
 * ✓ Расширена поддержка excluded_urls: теперь пропускают Rate Limit и Burst Detection
 * ✓ Поддержка wildcard паттернов (например: /api/*, /TEMP/* /file.php?*)
 * ✓ Новые методы управления исключениями:
 *   - addExcludedUrl($pattern) - добавить URL в исключения
 *   - removeExcludedUrl($pattern) - удалить URL из исключений
 *   - getExcludedUrls() - получить список исключенных URL
 *   - setExcludedUrls($patterns) - установить список исключений
 *   - clearExcludedUrls() - очистить все исключения
 *   - isUrlExcluded($url) - проверить исключен ли URL
 * ✓ Настройка 'excluded_urls' в jsChallengeSettings
 * ✓ Минимальное влияние на производительность (<0.1ms проверка паттернов)
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.1 - СТАТИСТИКА ЗАПРОСОВ В РЕАЛЬНОМ ВРЕМЕНИ (2025-12-02)
 * ============================================================================
 * 
 * НОВОЕ v2.5.1:
 * ✓ Добавлен счётчик запросов RPM (requests per minute)
 * ✓ Добавлен счётчик запросов RPS (requests per second)
 * ✓ Новый метод: incrementRequestCounter() - вызывается в protect()
 * ✓ Новый метод: getRequestsPerMinute() - возвращает RPM/RPS статистику
 * ✓ Новый метод: getRPMHistory() - история RPM за последние N минут
 * ✓ Минимальное влияние на производительность (2 операции INCR ~0.2ms)
 *
 * ============================================================================
 * ВЕРСИЯ 2.5.0 - ЗАЩИТА ОТ РАСПРЕДЕЛЁННОГО ПАРСИНГА (2025-12-01)
 * ============================================================================
 * 
 * КЛЮЧЕВЫЕ ИЗМЕНЕНИЯ v2.5:
 * ✓ Slow bot теперь БЛОКИРУЕТСЯ сразу (раньше только extended tracking)
 * ✓ Новая защита от ботнетов: блокировка если нет cookie после N запросов
 * ✓ Ужесточена проверка HTTP заголовков
 * ✓ Снижен порог для isPotentialSlowBot (3 запроса вместо 5)
 * ✓ Новая настройка: no_cookie_block_threshold (по умолчанию 3)
 *
 * ============================================================================
 * ВЕРСИЯ 2.4.0 - RATE LIMIT + BURST РАБОТАЮТ ПРИ 429 (2025-11-30)
 * ============================================================================
 * 
 * ИЗМЕНЕНИЯ v2.4:
 * ✓ Rate Limit и Burst Detection работают ВСЕГДА (даже при 429)
 * ✓ Счетчики увеличиваются даже когда показывается 429 ошибка
 * ✓ Новая система violations с автоматической блокировкой через API
 * ✓ Красивая страница 429 с предупреждением о блокировке
 * ✓ Новые настройки: rate_limit_api_block_threshold, burst_api_block_threshold
 * ✓ Новые методы: getTotalViolations(), incrementViolations(), getViolationsStatus()
 * 
 * НАСТРОЙКИ БЛОКИРОВКИ ЧЕРЕЗ API:
 * - rate_limit_api_block_threshold: 3 (блокировать через API после 3 нарушений)
 * - burst_api_block_threshold: 2 (блокировать через API после 2 burst)
 * - combined_api_block_threshold: 4 (блокировать если сумма violations >= 4)
 *
 * ============================================================================
 * ВЕРСИЯ 2.3.1 - РАБОЧИЙ RATE LIMIT + BURST (2025-11-28)
 * ============================================================================
 * 
 * ИСПРАВЛЕНО И ДОБАВЛЕНО:
 * ✓ Rate Limit - РАБОТАЕТ! Вариант B: cookie пользователи получают ×2 лимиты
 * ✓ Burst Detection - РАБОТАЕТ! Вариант B: cookie пользователи получают ×2 порог
 * ✓ Добавлены тестовые методы: testRateLimit(), testBurst()
 * ✓ Добавлены методы статуса: getRateLimitStatus(), getBurstStatus()
 * 
 * НАСТРОЙКИ ПО УМОЛЧАНИЮ:
 * - Rate Limit: 60/мин, 200/5мин, 800/час (×2 для cookie)
 * - Burst: 5 запросов за 10 сек (×2 для cookie = 10 запросов)
 * - cookie_multiplier: 2.0
 *
 * ============================================================================
 * ВЕРСИЯ 2.3 - ОПТИМИЗАЦИЯ ПАМЯТИ REDIS (2025-11-28)
 * ============================================================================
 * 
 * ОПТИМИЗИРОВАНО:
 * ✓ Rate Limit объединён в один ключ на IP (было 4-5 ключей, стало 1)
 * ✓ Global Rate Limit использует скользящее окно (было 1 ключ/сек, стало 1 ключ/IP)
 * ✓ Уменьшены TTL для tracking данных (3 часа → 1.5 часа)
 * ✓ Уменьшены TTL для extended tracking (24 часа → 6 часов)
 * ✓ Ожидаемое сокращение ключей: в 3-4 раза меньше!
 * 
 * БЫЛО: ~5-7 ключей на IP (12,000+ ключей на 2,000 IP)
 * СТАЛО: ~2-3 ключа на IP (4,000-6,000 ключей на 2,000 IP)
 * 
 * ============================================================================
 * ВЕРСИЯ 2.2 - ИСПРАВЛЕНИЕ ЛОЖНЫХ БЛОКИРОВОК AJAX (2025-11-27)
 * ============================================================================
 * 
 * ИСПРАВЛЕНО:
 * ✓ checkSuspiciousHeaders() теперь корректно обрабатывает AJAX/Fetch запросы
 * ✓ Поиск DLE и другие AJAX-функции больше не вызывают ложных блокировок
 * ✓ Добавлена детекция AJAX через X-Requested-With, Sec-Fetch-Mode, Sec-Fetch-Dest
 * ✓ Для AJAX применяются мягкие проверки (только критичные заголовки)
 * 
 * ============================================================================
 * ВЕРСИЯ 2.1 - УСИЛЕННАЯ ДЕТЕКЦИЯ "УМНЫХ" БОТОВ (2025-11-26)
 * ============================================================================
 * 
 * ФУНКЦИИ v2.1:
 * ✓ checkSuspiciousHeaders() - проверка HTTP заголовков (Accept-Language и т.д.)
 * ✓ analyzeRequestTypes() - анализ типов запросов (только HTML = бот)
 * 
 * УЖЕСТОЧЕННЫЕ ЛИМИТЫ:
 * ✓ max_requests_per_minute: 60 → 40
 * ✓ max_requests_per_5min: 200 → 120
 * ✓ max_requests_per_hour: 1000 → 600
 * ✓ burst_threshold: 20 → 15
 * ✓ slow_bot_threshold_hours: 4 → 2
 * ✓ blockThreshold: 10/12 → 7/8
 * 
 * НОВЫЕ ПРОВЕРКИ В analyzeSlowBotBehavior():
 * ✓ Проверка HTTP заголовков (боты не шлют Accept-Language)
 * ✓ Проверка типов запросов (боты запрашивают только HTML)
 * ✓ Проверка отсутствия cookies после 12+ запросов
 * ✓ Расширенный диапазон детекции регулярности (30-900 сек)
 * 
 * ============================================================================
 * 
 * ЧТО БЫЛО УДАЛЕНО (тяжелые операции перенесены в cleanup.php):
 * ✗ cleanup() - использовал keys() для сканирования всех ключей
 * ✗ cleanupUserHashData() - использовал keys() множество раз
 * ✗ deepCleanup() - вызывал cleanup() и cleanupUserHashData()
 * ✗ forceCleanup() - агрессивная очистка с неограниченным SCAN
 * 
 * ЧТО БЫЛО ОПТИМИЗИРОВАНО:
 * ✓ getRedisMemoryInfo() - теперь читает готовые метрики вместо SCAN
 * ✓ cleanup_probability = 999999 (автоочистка отключена)
 * 
 * ЧТО ДОБАВЛЕНО:
 * ✓ getCleanupStatus() - проверка работы cleanup.php
 * 
 * ============================================================================
 * УЛУЧШЕНИЯ ДЛЯ ВЫСОКИХ НАГРУЗОК (v2.0)
 * ============================================================================
 * 
 * 1. АТОМАРНЫЙ Rate Limit (без race condition):
 *    - checkRateLimit() использует Redis INCR вместо GET-SET
 *    - Надёжная работа при >1000 req/sec
 *    - Отдельные ключи для каждого временного окна
 * 
 * 2. ГЛОБАЛЬНЫЙ Rate Limit (защита от DDoS):
 *    - checkGlobalRateLimit() срабатывает при >100 req/sec с одного IP
 *    - Работает ДО проверки ботов - защита от поддельных User-Agent
 * 
 * 3. WHITELIST верифицированных поисковиков:
 *    - isWhitelistedSearchEngine() - мгновенная проверка кеша
 *    - addToSearchEngineWhitelist() - кеширование на 24 часа после rDNS
 *    - Поисковики НЕ БЛОКИРУЮТСЯ даже при высокой нагрузке
 * 
 * 4. SCAN вместо KEYS:
 *    - getRDNSRateLimitStats() - неблокирующая статистика
 *    - clearRDNSCache() - неблокирующая очистка
 *    - clearSearchEngineWhitelist() - очистка whitelist
 * 
 * ============================================================================
 * КРИТИЧЕСКОЕ ТРЕБОВАНИЕ:
 * cleanup.php ДОЛЖЕН запускаться по cron каждые 5-10 минут!
 * Без cleanup.php Redis переполнится и защита не будет работать!
 * 
 * Настройка cron:
 * Каждые 5 минут: php /var/www/your-site/cleanup.php >> /var/log/cleanup.log 2>&1
 * 
 * ОЖИДАЕМАЯ ПРОИЗВОДИТЕЛЬНОСТЬ:
 * - Обычные запросы: 2-5ms (до оптимизации: 5-10ms)
 * - Запросы с очисткой: 2-5ms (до оптимизации: 100-500ms)
 * - getRedisMemoryInfo(): <1ms (до оптимизации: 100-200ms)
 * - checkRateLimit(): <1ms (атомарные операции)
 * - Общий прирост: в 5-50 раз быстрее!
 * 
 * ============================================================================
 */

// ═══════════════════════════════════════════════════════════════════════════
// ЗАЩИТА ОТ ПОВТОРНОГО ОБЪЯВЛЕНИЯ КЛАССА
// Предотвращает ошибку "Cannot declare class" при множественном include
// ═══════════════════════════════════════════════════════════════════════════
if (!class_exists('RedisBotProtectionNoSessions')) {

class RedisBotProtectionNoSessions {
    private $redis;
    private $cookieName = 'visitor_verified';
    private $secretKey = 'your_secret_key_here_change_this12345!@#$';
    private $cookieLifetime = 86400 * 30; // 30 дней
    
    // Префиксы для Redis ключей
    private $redisPrefix = 'bot_protection:';
    private $trackingPrefix = 'tracking:';
    private $blockPrefix = 'blocked:';
    private $cookiePrefix = 'cookie:';
    private $rdnsPrefix = 'rdns:';
    private $userHashPrefix = 'user_hash:';
    
    // TTL настройки (ОПТИМИЗИРОВАНО для экономии памяти v2.3)
    private $ttlSettings = [
        'tracking_ip' => 5400,          // 1.5 часа (было 3 часа) - основной трекинг
        'cookie_blocked' => 7200,       // 2 часа - блокировка по cookie
        'ip_blocked' => 86400,          // 24 часа - блокировка IP
        'ip_blocked_repeat' => 259200,  // 3 дня - повторная блокировка
        'rdns_cache' => 1800,           // 30 мин - кеш rDNS
        'logs' => 86400,                // 1 день (было 2 дня) - логи
        'cleanup_interval' => 1800,     // 30 мин
        'user_hash_blocked' => 86400,   // 1 день (было 2 дня) - блокировка user hash
        'user_hash_tracking' => 10800,  // 3 часа (было 6 часов) - трекинг user hash
        'user_hash_stats' => 259200,    // 3 дня (было 7 дней) - статистика
        'extended_tracking' => 21600,   // 6 часов (было 24 часа) - расширенный трекинг
        'rate_limit' => 3600,           // НОВОЕ: 1 час для rate limit hash
    ];
    
    // Настройки для медленных ботов (УЖЕСТОЧЕНО для борьбы с умными ботами)
    private $slowBotSettings = [
        'min_requests_for_analysis' => 3,
        'slow_bot_threshold_hours' => 2,         // Снижено с 4 - быстрее детектим
        'slow_bot_min_requests' => 10,           // Снижено с 15
        'long_session_hours' => 1,               // Снижено с 2
        'suspicious_regularity_variance' => 300, // Увеличено с 100 - шире детекция
    ];
    
    // ═══════════════════════════════════════════════════════════════════════
    // НАСТРОЙКИ ДЕТЕКЦИИ БОТОВ ПО HTTP ЗАГОЛОВКАМ
    // ОБНОВЛЕНО v2.5: Ужесточены пороги
    // ═══════════════════════════════════════════════════════════════════════
    private $headerDetectionSettings = [
        // ═══════════════════════════════════════════════════════════════
        // v2.5.11: УВЕЛИЧЕНЫ ПОРОГИ для защиты от cloaking detection
        // Слишком низкие пороги блокировали Google анонимных краулеров
        // ═══════════════════════════════════════════════════════════════
        'block_score_threshold' => 12,   // v2.5.11: Увеличено с 5 до 12 (строже!)
        'tracking_score_threshold' => 8, // v2.5.11: Увеличено с 2 до 8 (строже!)
        'enabled' => true,               // Включить/выключить детекцию по заголовкам
    ];
    
    // Настройки rate limiting и защиты от нагрузки
    private $rateLimitSettings = [
        // ═══════════════════════════════════════════════════════════════════
        // v2.5.11: СМЯГЧЕНЫ ЛИМИТЫ для защиты от cloaking detection
        // Предыдущие лимиты (30/min) блокировали Google анонимных краулеров
        // Новые лимиты позволяют обычным пользователям свободно работать
        // ═══════════════════════════════════════════════════════════════════
        'max_requests_per_minute' => 120,        // v2.5.11: Увеличено с 30 до 120 (×4!)
        'max_requests_per_5min' => 300,          // v2.5.11: Увеличено с 100 до 300 (×3!)
        'max_requests_per_hour' => 800,          // v2.5.11: Увеличено с 400 до 800 (×2!)
        'cookie_multiplier' => 3.0,              // v2.5.11: Увеличено с 2.0 до 3.0 (больше бонус!)
        'burst_threshold' => 20,                 // v2.5.11: Увеличено с 10 до 20 (×2!)
        'burst_window' => 10,                    // Окно для детекции всплеска (секунды)
        'ua_change_threshold' => 10,             // Макс. смен UA за сессию
        'ua_change_time_window' => 300,          // Окно для детекции смены UA (5 мин)
        'progressive_block_duration' => 1800,    // Прогрессивная блокировка (30 мин)
        'aggressive_block_duration' => 7200,     // Агрессивная блокировка (2 часа)
        
        // ═══════════════════════════════════════════════════════════════════
        // НОВОЕ v2.4: Пороги для автоматической блокировки через API
        // ═══════════════════════════════════════════════════════════════════
        'rate_limit_api_block_threshold' => 3,   // Блокировать через API после N нарушений rate limit
        'burst_api_block_threshold' => 2,        // Блокировать через API после N burst'ов
        'combined_api_block_threshold' => 4,     // Блокировать если сумма всех violations >= N
        
        // ═══════════════════════════════════════════════════════════════════
        // v2.5.11: КРИТИЧНО! НЕ БЛОКИРОВАТЬ за отсутствие cookie!
        // Предыдущее значение (3) блокировало Google анонимных краулеров
        // и обычных пользователей, вызывая cloaking detection
        // ═══════════════════════════════════════════════════════════════════
        'no_cookie_block_threshold' => 999,      // v2.5.11: Было 3, ОТКЛЮЧЕНО (999)!
        'slow_bot_instant_block' => true,        // Блокировать slow bot сразу (true) или только tracking (false)
    ];
    
    // Настройки защиты от переполнения Redis
    private $globalProtectionSettings = [
        'cleanup_threshold' => 5000,             // Начать очистку при достижении
        'cleanup_batch_size' => 100,             // Удалять за один раз
        'cleanup_probability' => 999999,  // ОТКЛЮЧЕНО - используйте cleanup.php             // Проверять каждый N-й запрос (1 из 50 = 2%)
        'max_cleanup_time_ms' => 50,            // Максимум 50ms на очистку
    ];
    
    // Настройки rate limiting для rDNS проверок
    private $rdnsLimitSettings = [
        'max_rdns_per_minute' => 60,            // Максимум rDNS проверок в минуту
        'rdns_cache_ttl' => 1800,               // Кеш результатов 30 минут
        'rdns_negative_cache_ttl' => 300,       // Кеш негативных результатов 5 минут
        'rdns_on_limit_action' => 'skip',       // 'skip' или 'block' при превышении
        'trust_search_engine_ua_on_limit' => true, // НОВОЕ: Доверять UA поисковика при превышении лимита
    ];
    
    private $globalPrefix = 'global:';
	
	// Настройки API для блокировки через iptables
    private $apiSettings = [
        'enabled' => false,                                              // Включить/выключить API блокировку
        'url' => 'https://mysite.com/redis-bot_protection/API/iptables.php',           // URL вашего API
        'api_key' => '12345',                          // API ключ (из settings.php)
        'timeout' => 5,                                                 // Таймаут запроса (секунды)
        'block_on_redis' => true,                                       // Блокировать в Redis (локально)
        'block_on_api' => true,                                         // Блокировать через API (iptables)
        'auto_unblock' => true,                                         // Автоматически разблокировать через API при истечении TTL
        'retry_on_failure' => 2,                                        // Количество попыток при ошибке API
        'log_api_errors' => true,                                       // Логировать ошибки API
        'user_agent' => 'uptimerobot',            // User-Agent для API запросов
        'verify_ssl' => true,                                           // Проверять SSL сертификат
    ];
    
    // Список поисковиков с точными паттернами
    private $allowedSearchEngines = [
        'googlebot' => [
            'user_agent_patterns' => [
                'googlebot', 'google', 'googleother',
                'googlebot-image', 'googlebot-news', 'googlebot-video'
            ],
            'rdns_patterns' => ['.googlebot.com', '.google.com'],
            'ip_ranges' => [
                // ═══════════════════════════════════════════════════════════════
                // ОФИЦИАЛЬНЫЙ СПИСОК IP ОТ GOOGLE (обновлено 2025-12-18)
                // Источник: https://developers.google.com/search/apis/ipranges/googlebot.json
                // Дата создания списка: 2025-12-17T15:46:05.000000
                // Всего: 269 диапазонов (127 IPv4 + 142 IPv6)
                // ═══════════════════════════════════════════════════════════════
                
                // IPv4 RANGES (127 диапазонов) - ОФИЦИАЛЬНЫЕ ОТ GOOGLE
                '66.249.64.0/27', '66.249.64.32/27', '66.249.64.64/27', '66.249.64.96/27',
                '66.249.64.128/27', '66.249.64.160/27', '66.249.64.192/27', '66.249.64.224/27',
                '66.249.65.0/27', '66.249.65.32/27', '66.249.65.64/27', '66.249.65.96/27',
                '66.249.65.128/27', '66.249.65.160/27', '66.249.65.192/27', '66.249.65.224/27',
                '66.249.66.0/27', '66.249.66.32/27', '66.249.66.64/27', '66.249.66.96/27',
                '66.249.66.128/27', '66.249.66.160/27', '66.249.66.192/27', '66.249.66.224/27',
                '66.249.67.0/27', '66.249.67.32/27', '66.249.67.64/27',
                '66.249.68.0/27', '66.249.68.32/27', '66.249.68.64/27', '66.249.68.96/27',
                '66.249.68.128/27', '66.249.68.160/27', '66.249.68.192/27',
                '66.249.69.0/27', '66.249.69.32/27', '66.249.69.64/27', '66.249.69.96/27',
                '66.249.69.128/27', '66.249.69.160/27', '66.249.69.192/27', '66.249.69.224/27',
                '66.249.70.0/27', '66.249.70.32/27', '66.249.70.64/27', '66.249.70.96/27',
                '66.249.70.128/27', '66.249.70.160/27', '66.249.70.192/27', '66.249.70.224/27',
                '66.249.71.0/27', '66.249.71.32/27', '66.249.71.64/27', '66.249.71.96/27',
                '66.249.71.128/27', '66.249.71.160/27', '66.249.71.192/27', '66.249.71.224/27',
                '66.249.72.0/27', '66.249.72.32/27', '66.249.72.64/27', '66.249.72.128/27',
                '66.249.72.160/27', '66.249.72.192/27', '66.249.72.224/27',
                '66.249.73.0/27', '66.249.73.32/27', '66.249.73.64/27', '66.249.73.96/27',
                '66.249.73.128/27', '66.249.73.160/27', '66.249.73.192/27', '66.249.73.224/27',
                '66.249.74.0/27', '66.249.74.32/27', '66.249.74.64/27', '66.249.74.96/27',
                '66.249.74.128/27', '66.249.74.160/27', '66.249.74.192/27', '66.249.74.224/27',
                '66.249.75.0/27', '66.249.75.32/27', '66.249.75.64/27', '66.249.75.96/27',
                '66.249.75.128/27', '66.249.75.160/27', '66.249.75.192/27', '66.249.75.224/27',
                '66.249.76.0/27', '66.249.76.32/27', '66.249.76.64/27', '66.249.76.96/27',
                '66.249.76.128/27', '66.249.76.160/27', '66.249.76.192/27', '66.249.76.224/27',
                '66.249.77.0/27', '66.249.77.32/27', '66.249.77.64/27', '66.249.77.96/27',
                '66.249.77.128/27', '66.249.77.160/27', '66.249.77.192/27', '66.249.77.224/27',
                '66.249.78.0/27', '66.249.78.32/27', '66.249.78.64/27', '66.249.78.96/27',
                '66.249.78.128/27', '66.249.78.160/27',
                '66.249.79.0/27', '66.249.79.32/27', '66.249.79.64/27', '66.249.79.128/27',
                '66.249.79.160/27', '66.249.79.192/27', '66.249.79.224/27',
                '192.178.4.0/27', '192.178.4.32/27', '192.178.4.64/27', '192.178.4.96/27',
                '192.178.4.128/27', '192.178.4.160/27', '192.178.4.192/27',
                '192.178.5.0/27',
                '192.178.6.0/27', '192.178.6.32/27', '192.178.6.64/27', '192.178.6.96/27',
                '192.178.6.128/27', '192.178.6.160/27', '192.178.6.192/27', '192.178.6.224/27',
                '192.178.7.0/27', '192.178.7.32/27', '192.178.7.64/27', '192.178.7.96/27',
                '192.178.7.128/27', '192.178.7.160/27', '192.178.7.192/27', '192.178.7.224/27',
                '34.22.85.0/27',
                '34.64.82.64/28', '34.65.242.112/28', '34.80.50.80/28', '34.88.194.0/28',
                '34.89.10.80/28', '34.89.198.80/28', '34.96.162.48/28',
                '34.100.182.96/28', '34.101.50.144/28', '34.118.66.0/28', '34.118.254.0/28',
                '34.126.178.96/28', '34.146.150.144/28', '34.147.110.144/28',
                '34.151.74.144/28', '34.152.50.64/28', '34.154.114.144/28', '34.155.98.32/28',
                '34.165.18.176/28', '34.175.160.64/28', '34.176.130.16/28', '35.247.243.240/28',
                
                // IPv6 RANGES (142 диапазона) - ОФИЦИАЛЬНЫЕ ОТ GOOGLE
                '2001:4860:4801:2::/64', '2001:4860:4801:c::/64', '2001:4860:4801:f::/64',
                '2001:4860:4801:10::/64', '2001:4860:4801:12::/64', '2001:4860:4801:13::/64',
                '2001:4860:4801:14::/64', '2001:4860:4801:15::/64', '2001:4860:4801:16::/64',
                '2001:4860:4801:17::/64', '2001:4860:4801:18::/64', '2001:4860:4801:19::/64',
                '2001:4860:4801:1a::/64', '2001:4860:4801:1b::/64', '2001:4860:4801:1c::/64',
                '2001:4860:4801:1d::/64', '2001:4860:4801:1e::/64', '2001:4860:4801:1f::/64',
                '2001:4860:4801:20::/64', '2001:4860:4801:21::/64', '2001:4860:4801:22::/64',
                '2001:4860:4801:23::/64', '2001:4860:4801:24::/64', '2001:4860:4801:25::/64',
                '2001:4860:4801:26::/64', '2001:4860:4801:27::/64', '2001:4860:4801:28::/64',
                '2001:4860:4801:29::/64', '2001:4860:4801:2a::/64', '2001:4860:4801:2b::/64',
                '2001:4860:4801:2c::/64', '2001:4860:4801:2d::/64', '2001:4860:4801:2e::/64',
                '2001:4860:4801:2f::/64', '2001:4860:4801:30::/64', '2001:4860:4801:31::/64',
                '2001:4860:4801:32::/64', '2001:4860:4801:33::/64', '2001:4860:4801:34::/64',
                '2001:4860:4801:35::/64', '2001:4860:4801:36::/64', '2001:4860:4801:37::/64',
                '2001:4860:4801:38::/64', '2001:4860:4801:39::/64', '2001:4860:4801:3a::/64',
                '2001:4860:4801:3b::/64', '2001:4860:4801:3c::/64', '2001:4860:4801:3d::/64',
                '2001:4860:4801:3e::/64', '2001:4860:4801:3f::/64', '2001:4860:4801:40::/64',
                '2001:4860:4801:41::/64', '2001:4860:4801:42::/64', '2001:4860:4801:44::/64',
                '2001:4860:4801:45::/64', '2001:4860:4801:46::/64', '2001:4860:4801:47::/64',
                '2001:4860:4801:48::/64', '2001:4860:4801:49::/64', '2001:4860:4801:4a::/64',
                '2001:4860:4801:4b::/64', '2001:4860:4801:4c::/64', '2001:4860:4801:4d::/64',
                '2001:4860:4801:4e::/64', '2001:4860:4801:50::/64', '2001:4860:4801:51::/64',
                '2001:4860:4801:52::/64', '2001:4860:4801:53::/64', '2001:4860:4801:54::/64',
                '2001:4860:4801:55::/64', '2001:4860:4801:56::/64', '2001:4860:4801:57::/64',
                '2001:4860:4801:58::/64', '2001:4860:4801:59::/64', '2001:4860:4801:60::/64',
                '2001:4860:4801:61::/64', '2001:4860:4801:62::/64', '2001:4860:4801:63::/64',
                '2001:4860:4801:64::/64', '2001:4860:4801:65::/64', '2001:4860:4801:66::/64',
                '2001:4860:4801:67::/64', '2001:4860:4801:68::/64', '2001:4860:4801:69::/64',
                '2001:4860:4801:6a::/64', '2001:4860:4801:6b::/64', '2001:4860:4801:6c::/64',
                '2001:4860:4801:6d::/64', '2001:4860:4801:6e::/64', '2001:4860:4801:6f::/64',
                '2001:4860:4801:70::/64', '2001:4860:4801:71::/64', '2001:4860:4801:72::/64',
                '2001:4860:4801:73::/64', '2001:4860:4801:74::/64', '2001:4860:4801:75::/64',
                '2001:4860:4801:76::/64', '2001:4860:4801:77::/64', '2001:4860:4801:78::/64',
                '2001:4860:4801:79::/64', '2001:4860:4801:7a::/64', '2001:4860:4801:7b::/64',
                '2001:4860:4801:7c::/64', '2001:4860:4801:7d::/64', '2001:4860:4801:80::/64',
                '2001:4860:4801:81::/64', '2001:4860:4801:82::/64', '2001:4860:4801:83::/64',
                '2001:4860:4801:84::/64', '2001:4860:4801:85::/64', '2001:4860:4801:86::/64',
                '2001:4860:4801:87::/64', '2001:4860:4801:88::/64', '2001:4860:4801:90::/64',
                '2001:4860:4801:91::/64', '2001:4860:4801:92::/64', '2001:4860:4801:93::/64',
                '2001:4860:4801:94::/64', '2001:4860:4801:95::/64', '2001:4860:4801:96::/64',
                '2001:4860:4801:97::/64', '2001:4860:4801:a0::/64', '2001:4860:4801:a1::/64',
                '2001:4860:4801:a2::/64', '2001:4860:4801:a3::/64', '2001:4860:4801:a4::/64',
                '2001:4860:4801:a5::/64', '2001:4860:4801:a6::/64', '2001:4860:4801:a7::/64',
                '2001:4860:4801:a8::/64', '2001:4860:4801:a9::/64', '2001:4860:4801:aa::/64',
                '2001:4860:4801:ab::/64', '2001:4860:4801:ac::/64', '2001:4860:4801:ad::/64',
                '2001:4860:4801:ae::/64', '2001:4860:4801:b0::/64', '2001:4860:4801:b1::/64',
                '2001:4860:4801:b2::/64', '2001:4860:4801:b3::/64', '2001:4860:4801:b4::/64',
                '2001:4860:4801:b5::/64',
            ]
        ],
        'bingbot' => [
            'user_agent_patterns' => ['bingbot', 'msnbot'],
            'rdns_patterns' => ['.search.msn.com'],
            'ip_ranges' => [
                // IPv4 ranges
                '40.77.167.0/24',      // Bing crawler
                '157.55.39.0/24',      // MSN Bot
                '207.46.13.0/24',      // Microsoft crawler
                '40.77.188.0/22',      // Bing services
                '157.55.32.0/20',      // Microsoft crawlers
                '207.46.0.0/16',       // Microsoft network
                '131.253.24.0/22',     // Microsoft services
                '131.253.61.0/24',     // Bing crawlers
                '65.52.0.0/14',        // Microsoft services
                '199.30.16.0/20',      // Microsoft edge
                '13.64.0.0/11',        // Azure (Bing uses)
                '20.0.0.0/8',          // Azure Bing crawlers
                '52.0.0.0/8',          // Azure services
                // IPv6 ranges
                '2620:1ec:c11::/48',   // Bing IPv6
                '2001:4898::/32',      // Microsoft IPv6
            ]
        ],
        'yandexbot' => [
            'user_agent_patterns' => ['yandexbot', 'yandex'],
            'rdns_patterns' => ['.yandex.ru', '.yandex.net', '.yandex.com'],
            'ip_ranges' => [
                // ═══════════════════════════════════════════════════════════════
                // ОФИЦИАЛЬНЫЙ СПИСОК IP ОТ ЯНДЕКСА (обновлено 2025-12-18)
                // Источники: 
                // 1. SPF записи (_spf-ipv4.yandex.ru, _spf-ipv6.yandex.ru)
                // 2. Официальная страница: https://yandex.ru/ips
                // 3. Архивные данные (2023)
                // Всего: 22 IPv4 + 6 IPv6 = 28 диапазонов
                // ═══════════════════════════════════════════════════════════════
                
                // IPv4 RANGES (22 диапазона) - ОФИЦИАЛЬНЫЕ ОТ ЯНДЕКСА
                // Из SPF записей (декабрь 2025):
                '5.45.192.0/18',        // Yandex main (покрывает /19 из SPF)
                '5.255.192.0/18',       // Yandex services
                '37.9.64.0/18',         // Yandex network (покрывает 37.9.109.0/24 из SPF)
                '37.140.128.0/18',      // Yandex services
                '77.88.0.0/18',         // Main Yandex range
                '84.201.128.0/18',      // Yandex cloud
                '87.250.224.0/19',      // Yandex services
                '93.158.128.0/18',      // Yandex crawlers (покрывает 93.158.136.48/28 из SPF)
                '95.108.128.0/17',      // Yandex network (покрывает 95.108.130.0/23 и 95.108.192.0/18 из SPF)
                '141.8.128.0/18',       // Yandex crawlers (покрывает 141.8.132.0/24 из SPF)
                '213.180.192.0/19',     // Yandex services (покрывает 213.180.223.192/26 из SPF)
                
                // Дополнительные из архивных данных (2023):
                '84.252.160.0/19',      // Yandex additional
                '90.156.176.0/22',      // Yandex services
                '178.154.128.0/18',     // Yandex services
                '185.32.187.0/24',      // Yandex bot
                
                // Узкие специфические диапазоны из SPF (для точности):
                '37.9.109.0/24',        // Yandex specific
                '93.158.136.48/28',     // Yandex specific
                '95.108.130.0/23',      // Yandex specific
                '95.108.192.0/18',      // Yandex specific
                '141.8.132.0/24',       // Yandex specific
                '213.180.223.192/26',   // Yandex specific
                '185.32.185.0/24',      // Yandex bot (дополнительный)
                
                // IPv6 RANGES (6 диапазонов) - ОФИЦИАЛЬНЫЕ ОТ ЯНДЕКСА
                // Основной диапазон (покрывает все остальные):
                '2a02:6b8::/29',        // Yandex IPv6 main (покрывает все ниже)
                
                // Специфические подсети из SPF (для точности):
                '2a02:6b8:c00::/40',    // Yandex services IPv6
                '2a02:6b8:0:1472::/64', // Yandex specific
                '2a02:6b8:0:1619::/64', // Yandex specific
                '2a02:6b8:0:1a2d::/64', // Yandex specific
                '2a02:6b8:0:801::/64',  // Yandex specific
            ]
        ],
        'slurp' => [
            'user_agent_patterns' => ['slurp'],
            'rdns_patterns' => ['.crawl.yahoo.net'],
            'ip_ranges' => [
                // IPv4 ranges
                '98.136.0.0/14',       // Yahoo network
                '72.30.0.0/16',        // Yahoo crawlers
                '67.195.0.0/16',       // Yahoo services
                '74.6.0.0/16',         // Yahoo network
                '68.142.192.0/18',     // Yahoo crawlers
                '209.191.64.0/18',     // Yahoo services
                '76.13.0.0/16',        // Yahoo network
                // IPv6 ranges
                '2001:4998::/32',      // Yahoo IPv6
            ]
        ],
        'duckduckbot' => [
            'user_agent_patterns' => ['duckduckbot'],
            'rdns_patterns' => ['.duckduckgo.com'],
            'ip_ranges' => [
                // IPv4 ranges
                '20.191.45.0/24',      // DuckDuckGo bot
                '40.88.21.0/24',       // DuckDuckGo services
                '52.142.0.0/16',       // DuckDuckGo Azure
                '20.191.0.0/16',       // DuckDuckGo network
            ]
        ],
        'baiduspider' => [
            'user_agent_patterns' => ['baiduspider'],
            'rdns_patterns' => ['.baidu.com', '.baidu.jp'],
            'ip_ranges' => [
                // IPv4 ranges
                '123.125.71.0/24',     // Baidu spider
                '180.76.0.0/16',       // Main Baidu range
                '220.181.0.0/16',      // Baidu network
                '119.63.192.0/21',     // Baidu crawlers
                '202.46.48.0/20',      // Baidu services
                '61.135.0.0/16',       // Baidu network
                '123.125.0.0/16',      // Baidu services
                '202.108.22.0/24',     // Baidu spider
                '220.181.108.0/24',    // Baidu crawlers
            ]
        ],
        'facebookexternalhit' => [
            'user_agent_patterns' => ['facebookexternalhit', 'facebookcatalog'],
            'rdns_patterns' => ['.facebook.com', '.fbsv.net'],
            'skip_forward_verification' => true,
            'ip_ranges' => [
                // IPv4 ranges
                '31.13.24.0/21',       // Facebook network
                '31.13.64.0/18',       // Facebook services
                '66.220.144.0/20',     // Facebook crawlers
                '69.63.176.0/20',      // Facebook network
                '69.171.224.0/19',     // Facebook services
                '74.119.76.0/22',      // Facebook crawlers
                '103.4.96.0/22',       // Facebook Asia
                '129.134.0.0/16',      // Facebook network
                '157.240.0.0/16',      // Facebook services
                '173.252.64.0/18',     // Facebook crawlers
                '179.60.192.0/22',     // Facebook Latin America
                '185.60.216.0/22',     // Facebook Europe
                '204.15.20.0/22',      // Facebook network
                // IPv6 ranges
                '2a03:2880::/32',      // Facebook IPv6
                '2620:0:1c00::/40',    // Facebook services IPv6
            ]
        ],
        'twitterbot' => [
            'user_agent_patterns' => ['twitterbot'],
            'rdns_patterns' => ['.twitter.com', '.twttr.com'],
            'skip_forward_verification' => true,
            'ip_ranges' => [
                // IPv4 ranges
                '192.133.76.0/22',     // Twitter network
                '199.16.156.0/22',     // Twitter services
                '199.59.148.0/22',     // Twitter crawlers
                '199.96.56.0/21',      // Twitter network
                '202.160.128.0/22',    // Twitter Asia
                '104.244.42.0/24',     // Twitter bot
            ]
        ],
        'linkedinbot' => [
            'user_agent_patterns' => ['linkedinbot'],
            'rdns_patterns' => ['.linkedin.com'],
            'skip_forward_verification' => true,
            'ip_ranges' => [
                // IPv4 ranges
                '108.174.0.0/16',      // LinkedIn network
                '138.91.0.0/16',       // LinkedIn services
                '185.63.144.0/22',     // LinkedIn Europe
                '216.52.16.0/22',      // LinkedIn crawlers
            ]
        ],
        'applebot' => [
            'user_agent_patterns' => ['applebot'],
            'rdns_patterns' => ['.applebot.apple.com'],
            'ip_ranges' => [
                // IPv4 ranges
                '17.0.0.0/8',          // Apple network (широкий, но включает Applebot)
            ]
        ],
        'amazonbot' => [
            'user_agent_patterns' => ['amazonbot', 'amazon bot', 'amazon-bot'],
            'rdns_patterns' => ['.amazon.com', '.amazon', '.crawl.amazonbot.amazon'],
            'ip_ranges' => [
                // IPv4 ranges (AWS ranges - Amazonbot использует AWS)
                '3.0.0.0/15',          // AWS us-east-1
                '52.94.0.0/16',        // AWS global
                '54.0.0.0/8',          // AWS main range
                '18.0.0.0/8',          // AWS services
            ]
        ],
        'petalbot' => [
            'user_agent_patterns' => ['petalbot'],
            'rdns_patterns' => ['.petalsearch.com'],
            'ip_ranges' => [
                // IPv4 ranges
                '114.119.128.0/17',    // PetalBot Asia
                '222.186.0.0/16',      // Huawei network
            ]
        ],
        'sogou' => [
            'user_agent_patterns' => ['sogou'],
            'rdns_patterns' => ['.sogou.com'],
            'ip_ranges' => [
                // IPv4 ranges
                '106.38.241.0/24',     // Sogou spider
                '123.126.113.0/24',    // Sogou network
                '220.181.125.0/24',    // Sogou crawlers
            ]
        ],
        'telegrambot' => [
            'user_agent_patterns' => ['telegrambot', 'telegram bot', 'tgbot'],
            'rdns_patterns' => ['.telegram.org', '.ptr.telegram.org'],
            'skip_forward_verification' => true  // PTR записи Telegram не имеют forward DNS
        ],
        // ═══════════════════════════════════════════════════════════════════
        // v2.5.11: GOOGLE СЕРВИСЫ для защиты от cloaking detection
        // Google использует эти сервисы для анонимной проверки сайтов
        // ═══════════════════════════════════════════════════════════════════
        'google-lighthouse' => [
            'user_agent_patterns' => [
                'chrome-lighthouse', 
                'lighthouse',
                'mozilla/5.0 (x11; linux x86_64) applewebkit/537.36 (khtml, like gecko) chrome'
            ],
            'rdns_patterns' => ['.google.com', '.googlebot.com'],
            'skip_forward_verification' => false,
            'ip_ranges' => [
                // Использует те же диапазоны что и Googlebot
                '66.249.64.0/19',
                '66.102.0.0/20',
            ]
        ],
        'google-pagespeed' => [
            'user_agent_patterns' => [
                'google page speed insights',
                'chrome-lighthouse',
                'google-read-aloud',
                'googleproducer'
            ],
            'rdns_patterns' => ['.google.com', '.googlebot.com'],
            'skip_forward_verification' => false
        ],
        'google-adsbot' => [
            'user_agent_patterns' => [
                'adsbot-google',
                'adsbot-google-mobile',
                'mediapartners-google'
            ],
            'rdns_patterns' => ['.google.com', '.googlebot.com'],
            'skip_forward_verification' => false
        ],
        'google-tools' => [
            'user_agent_patterns' => [
                'google-inspectiontool',
                'google-structured-data-testing-tool',
                'google-amphtml',
                'google-extended',
                'feedfetcher-google'
            ],
            'rdns_patterns' => ['.google.com', '.googlebot.com'],
            'skip_forward_verification' => false
        ]
    ];
    
    // ═══════════════════════════════════════════════════════════════════════
    // JS CHALLENGE SETTINGS - Защита от ботов через JavaScript проверку
    // ═══════════════════════════════════════════════════════════════════════
    private $jsChallengeSettings = [
        'enabled' => true,                          // Включить JS Challenge
        'trigger_on_suspicious' => true,            // Показывать при подозрительном поведении
        'trigger_on_high_violations' => true,       // Показывать при высоких violations
        'violations_threshold' => 5,                // v2.5.11: Увеличено с 3 до 5 (строже!)
        'trigger_on_slow_bot' => true,              // Показывать для slow bot
        
        // ═══════════════════════════════════════════════════════════════════
        // v2.5.11: КРИТИЧНО! НЕ показывать JS Challenge ВСЕМ без cookie!
        // Предыдущее значение (true) показывало Challenge КАЖДОМУ новому
        // посетителю, включая Google анонимных краулеров → cloaking detection!
        // ═══════════════════════════════════════════════════════════════════
        'trigger_on_no_cookie' => true,             // v2.5.14: ВКЛЮЧЕНО - показывать JS Challenge без cookie!
        'no_cookie_threshold' => 1,                 // После 1 запроса без cookie → показать challenge
        
        'token_ttl' => 3600,                        // TTL токена JS Challenge (1 час)
        'token_name' => 'murkir_js_token',          // Имя cookie с токеном
        'min_solve_time' => 2000,                   // Минимальное время решения (ms)
        'pow_difficulty' => 3,                      // Сложность PoW (количество нулей в начале хеша)
        'failure_block_threshold' => 3,             // Блокировать после N провалов Challenge (нормальный режим)
        
        // ═══════════════════════════════════════════════════════════════════
        // ИСКЛЮЧЕНИЯ URL - URL которые НЕ ПРОВЕРЯЮТСЯ защитой
        // v2.5.11: ДОБАВЛЕНЫ критичные для SEO URL
        // ═══════════════════════════════════════════════════════════════════
        // ВАЖНО: Исключённые URL пропускают ВСЕ проверки:
        // - JS Challenge
        // - Rate Limit (все временные окна)
        // - Burst Detection
        // Используйте только для доверенных endpoints!
        // ═══════════════════════════════════════════════════════════════════
        'excluded_urls' => [
            // v2.5.11: Критично для SEO и поисковых ботов:
            '/sitemap.xml',              // Sitemap для Google/Yandex
            '/sitemap',                  // Sitemap паттерны
            '/robots.txt',               // robots.txt
            '/feed/',                    // RSS feeds
            '/rss/',                     // RSS feeds альтернативный
            '/.well-known/',             // Tech endpoints (SSL verification, etc)
            '/favicon.ico',              // Favicon
			'/TEMP/IPv6-IPv4/IPv6-IPv4.php',  // Конкретный файл с любыми параметрами
			'/TEMP/IPv6-IPv4/IPv6-IPv4-PTR.php',  // Конкретный файл с любыми параметрами
            
            // Примеры дополнительных паттернов (раскомментируйте если нужно):
            // '/api/*',                 // Все API endpoints
            // '/admin/ajax/*',          // Все AJAX запросы админки
            // '/webhook/*',             // Все webhook endpoints
        ],
        
        // ═══════════════════════════════════════════════════════════════════
        // АДАПТИВНАЯ ЗАЩИТА v2.8.0 - АВТОМАТИЧЕСКОЕ УЖЕСТОЧЕНИЕ ПРИ АТАКЕ
        // ═══════════════════════════════════════════════════════════════════
        'adaptive_protection' => true,              // Включить адаптивную защиту (автоматическое переключение)
        'adaptive_threshold_normal' => 3,           // Порог провалов в нормальном режиме
        'adaptive_threshold_attack' => 1,           // Порог провалов во время атаки (агрессивный)
        
        // Критерии определения атаки (любой критерий = атака):
        'attack_rps_threshold' => 50,               // RPS выше этого = атака (запросов в секунду)
        'attack_failures_per_minute' => 30,         // Провалов JS Challenge за минуту > этого = атака
        'attack_blocks_per_minute' => 15,           // Блокировок за минуту > этого = атака
        
        // Критерии окончания атаки (ВСЕ критерии должны выполниться):
        'recovery_rps_threshold' => 20,             // RPS ниже этого = атака закончилась
        'recovery_duration' => 300,                 // Время в секундах (5 мин) низкого RPS для окончания атаки
    ];

    // ═══════════════════════════════════════════════════════════════════════
    // CUSTOM IP WHITELIST v2.5.12 - Белый список IP для ПОЛНОГО ПРОПУСКА
    // ═══════════════════════════════════════════════════════════════════════
    // 
    // IP адреса из этого списка пропускают ВСЕ проверки, включая:
    // - Rate Limit
    // - Burst Detection  
    // - JS Challenge
    // - User-Agent проверки
    // - Все остальные проверки
    //
    // Поддерживает:
    // - Одиночные IPv4: '192.168.1.100'
    // - Одиночные IPv6: '2001:db8::1'
    // - CIDR диапазоны IPv4: '10.0.0.0/8', '192.168.0.0/16'
    // - CIDR диапазоны IPv6: '2001:db8::/32'
    //
    // ВАЖНО: IP из этого списка полностью обходят защиту!
    // Используйте только для доверенных IP (серверы мониторинга, API клиенты и т.д.)
    // ═══════════════════════════════════════════════════════════════════════
    private $customIPWhitelist = [
        // Примеры (раскомментируйте или добавьте свои):
        // '192.168.1.100',          // Конкретный IPv4
        // '10.0.0.0/8',             // Приватная сеть /8
        // '172.16.0.0/12',          // Приватная сеть /12
        // '192.168.0.0/16',         // Приватная сеть /16
        // '2001:db8::/32',          // IPv6 CIDR диапазон
        // '::1',                     // IPv6 localhost
        // '127.0.0.1',              // IPv4 localhost
    ];

    
    public function __construct($redisHost = '127.0.0.1', $redisPort = 6379, $redisPassword = null, $redisDatabase = 0) {
        $this->initRedis($redisHost, $redisPort, $redisPassword, $redisDatabase);
        
    }
    
    private function initRedis($host, $port, $password, $database) {
        try {
            $this->redis = new Redis();
            
            if (!$this->redis->connect($host, $port, 2)) {
                throw new Exception("Cannot connect to Redis server at {$host}:{$port}");
            }
            
            if ($password) {
                if (!$this->redis->auth($password)) {
                    throw new Exception("Redis authentication failed");
                }
            }
            
            if (!$this->redis->select($database)) {
                throw new Exception("Cannot select Redis database {$database}");
            }
            
            $this->redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_JSON);
            $this->redis->setOption(Redis::OPT_PREFIX, $this->redisPrefix);
            
            if (!$this->redis->ping()) {
                throw new Exception("Redis ping failed");
            }
            
        } catch (Exception $e) {
            error_log("CRITICAL: Redis connection failed - " . $e->getMessage());
            throw $e;
        }
    }
    
    private function normalizeIPv6($ip) {
        if (!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            return $ip;
        }
        
        $binary = @inet_pton($ip);
        if ($binary === false) {
            return $ip;
        }
        
        $normalized = @inet_ntop($binary);
        return $normalized ?: $ip;
    }
    
    private function normalizeIP($ip) {
        $ip = trim($ip);
        
        if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            return $ip;
        }
        
        if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            return $this->normalizeIPv6($ip);
        }
        
        return $ip;
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // CUSTOM IP WHITELIST METHODS v2.5.12 - Управление белым списком IP
    // ═══════════════════════════════════════════════════════════════════════
    
    /**
     * Проверяет, находится ли IP в пользовательском белом списке
     * 
     * @param string $ip IP адрес для проверки
     * @return bool true если IP в белом списке
     */
    private function isCustomWhitelistedIP($ip) {
        if (empty($this->customIPWhitelist)) {
            return false;
        }
        
        $ip = $this->normalizeIP($ip);
        
        foreach ($this->customIPWhitelist as $whitelistEntry) {
            // Проверяем через ipInRange (поддерживает и одиночные IP и CIDR)
            if ($this->ipInRange($ip, $whitelistEntry)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Добавить IP или CIDR диапазон в белый список
     * 
     * @param string $ip IP адрес или CIDR диапазон
     * @return bool Успех операции
     */
    public function addCustomWhitelistIP($ip) {
        $ip = trim($ip);
        
        // Валидация: проверяем что это IP или CIDR
        if (strpos($ip, '/') !== false) {
            // CIDR формат
            list($subnet, $prefix) = explode('/', $ip);
            if (!filter_var($subnet, FILTER_VALIDATE_IP)) {
                error_log("Invalid CIDR format for custom whitelist: $ip");
                return false;
            }
        } else {
            // Одиночный IP
            if (!filter_var($ip, FILTER_VALIDATE_IP)) {
                error_log("Invalid IP format for custom whitelist: $ip");
                return false;
            }
        }
        
        // Проверяем, не добавлен ли уже
        if (!in_array($ip, $this->customIPWhitelist)) {
            $this->customIPWhitelist[] = $ip;
            error_log("Added to custom IP whitelist: $ip");
            return true;
        }
        
        return false; // Уже в списке
    }
    
    /**
     * Удалить IP или CIDR диапазон из белого списка
     * 
     * @param string $ip IP адрес или CIDR диапазон
     * @return bool Успех операции
     */
    public function removeCustomWhitelistIP($ip) {
        $ip = trim($ip);
        $key = array_search($ip, $this->customIPWhitelist);
        
        if ($key !== false) {
            unset($this->customIPWhitelist[$key]);
            $this->customIPWhitelist = array_values($this->customIPWhitelist); // Переиндексация
            error_log("Removed from custom IP whitelist: $ip");
            return true;
        }
        
        return false; // Не найден
    }
    
    /**
     * Получить текущий белый список IP
     * 
     * @return array Массив IP адресов и CIDR диапазонов
     */
    public function getCustomWhitelistIPs() {
        return $this->customIPWhitelist;
    }
    
    /**
     * Установить белый список IP (заменяет текущий)
     * 
     * @param array $ips Массив IP адресов и CIDR диапазонов
     * @return int Количество успешно добавленных записей
     */
    public function setCustomWhitelistIPs(array $ips) {
        $this->customIPWhitelist = [];
        $added = 0;
        
        foreach ($ips as $ip) {
            if ($this->addCustomWhitelistIP($ip)) {
                $added++;
            }
        }
        
        error_log("Custom IP whitelist set: $added entries");
        return $added;
    }
    
    /**
     * Очистить белый список IP
     * 
     * @return bool Успех операции
     */
    public function clearCustomWhitelist() {
        $count = count($this->customIPWhitelist);
        $this->customIPWhitelist = [];
        error_log("Custom IP whitelist cleared: $count entries removed");
        return true;
    }
    
    /**
     * Проверить, находится ли IP в белом списке (публичный метод)
     * 
     * @param string $ip IP адрес для проверки
     * @return array Информация о результате проверки
     */
    public function checkCustomWhitelist($ip) {
        $ip = $this->normalizeIP(trim($ip));
        $isWhitelisted = $this->isCustomWhitelistedIP($ip);
        
        $matchedEntry = null;
        if ($isWhitelisted) {
            foreach ($this->customIPWhitelist as $entry) {
                if ($this->ipInRange($ip, $entry)) {
                    $matchedEntry = $entry;
                    break;
                }
            }
        }
        
        return [
            'ip' => $ip,
            'whitelisted' => $isWhitelisted,
            'matched_entry' => $matchedEntry,
            'whitelist_count' => count($this->customIPWhitelist)
        ];
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // END CUSTOM IP WHITELIST METHODS
    // ═══════════════════════════════════════════════════════════════════════
    
    /**
     * Проверяет является ли IP адрес поисковым ботом по whitelist IP диапазонов
     * 
     * @param string $ip IP адрес для проверки
     * @param string $userAgent User-Agent для определения типа бота
     * @return array|false ['engine' => 'googlebot', 'matched_range' => '66.249.64.0/19'] или false
     */
    private function isSearchEngineByIP($ip, $userAgent = '') {
        // Сначала определяем поисковик по User-Agent
        $detectedEngine = null;
        $engineConfig = null;
        
        if (!empty($userAgent)) {
            foreach ($this->allowedSearchEngines as $engine => $config) {
                foreach ($config['user_agent_patterns'] as $pattern) {
                    if (stripos($userAgent, $pattern) !== false) {
                        $detectedEngine = $engine;
                        $engineConfig = $config;
                        break 2;
                    }
                }
            }
        }
        
        // Если нашли поисковик по UA, проверяем его IP ranges
        if ($detectedEngine && $engineConfig && !empty($engineConfig['ip_ranges'])) {
            foreach ($engineConfig['ip_ranges'] as $cidr) {
                if ($this->ipInRange($ip, $cidr)) {
                    return [
                        'engine' => $detectedEngine,
                        'matched_range' => $cidr,
                        'method' => 'ip_whitelist'
                    ];
                }
            }
        }
        
        // Если UA не совпал или IP не в диапазоне, проверяем все IP ranges
        // (на случай если UA подделан или отсутствует)
        foreach ($this->allowedSearchEngines as $engine => $config) {
            if (!empty($config['ip_ranges'])) {
                foreach ($config['ip_ranges'] as $cidr) {
                    if ($this->ipInRange($ip, $cidr)) {
                        return [
                            'engine' => $engine,
                            'matched_range' => $cidr,
                            'method' => 'ip_whitelist_fallback'
                        ];
                    }
                }
            }
        }
        
        return false;
    }
    
    private function getIPFingerprint($ip) {
        $ip = $this->normalizeIPv6($ip);
        
        if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            $parts = explode(':', $ip);
            if (count($parts) >= 4) {
                return implode(':', array_slice($parts, -4));
            }
            return substr($ip, -16);
        } else {
            $parts = explode('.', $ip);
            if (count($parts) >= 2) {
                return end($parts) . '.' . prev($parts);
            }
            return $ip;
        }
    }
    
    private function generateUserHash($ip = null) {
        $ip = $ip ?: $this->getRealIP();
        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? '';
        $acceptLanguage = $_SERVER['HTTP_ACCEPT_LANGUAGE'] ?? '';
        $acceptEncoding = $_SERVER['HTTP_ACCEPT_ENCODING'] ?? '';
        $accept = $_SERVER['HTTP_ACCEPT'] ?? '';
        
        $browserInfo = $this->getBrowserFingerprint($userAgent);
        
        $stableFingerprint = $userAgent . '|' . 
                            $acceptLanguage . '|' . 
                            $acceptEncoding . '|' . 
                            $accept . '|' .
                            $browserInfo['name'] . '|' .
                            $browserInfo['version'] . '|' .
                            $browserInfo['platform'] . '|' .
                            $this->secretKey;
        
        if (false /* isMobileDevice removed */) {
            $ipPart = $this->getIPFingerprint($ip);
            $stableFingerprint .= '|mobile|' . $ipPart;
        } else {
            $stableFingerprint .= '|desktop|' . $ip;
        }
        
        return hash('sha256', $stableFingerprint);
    }
    
    private function getBrowserFingerprint($userAgent) {
        $browser = [
            'name' => 'unknown',
            'version' => 'unknown',
            'platform' => 'unknown'
        ];
        
        if (preg_match('/Chrome\/(\d+\.\d+)/', $userAgent, $matches)) {
            $browser['name'] = 'Chrome';
            $browser['version'] = $matches[1];
        } elseif (preg_match('/Firefox\/(\d+\.\d+)/', $userAgent, $matches)) {
            $browser['name'] = 'Firefox';
            $browser['version'] = $matches[1];
        } elseif (preg_match('/Safari\/(\d+\.\d+)/', $userAgent, $matches)) {
            if (strpos($userAgent, 'Chrome') === false) {
                $browser['name'] = 'Safari';
                $browser['version'] = $matches[1];
            }
        } elseif (preg_match('/Edge\/(\d+\.\d+)/', $userAgent, $matches)) {
            $browser['name'] = 'Edge';
            $browser['version'] = $matches[1];
        } elseif (preg_match('/Edg\/(\d+\.\d+)/', $userAgent, $matches)) {
            $browser['name'] = 'EdgeChromium';
            $browser['version'] = $matches[1];
        }
        
        if (strpos($userAgent, 'Windows NT') !== false) {
            if (preg_match('/Windows NT (\d+\.\d+)/', $userAgent, $matches)) {
                $browser['platform'] = 'Windows_' . $matches[1];
            } else {
                $browser['platform'] = 'Windows';
            }
        } elseif (strpos($userAgent, 'Macintosh') !== false) {
            $browser['platform'] = 'macOS';
        } elseif (strpos($userAgent, 'Linux') !== false) {
            $browser['platform'] = 'Linux';
        } elseif (strpos($userAgent, 'Android') !== false) {
            $browser['platform'] = 'Android';
        } elseif (strpos($userAgent, 'iPhone') !== false || strpos($userAgent, 'iPad') !== false) {
            $browser['platform'] = 'iOS';
        }
        
        return $browser;
    }
    
    private function isUserHashBlocked() {
        try {
            $userHash = $this->generateUserHash();
            $blockKey = $this->userHashPrefix . 'blocked:' . $userHash;
            return $this->redis->exists($blockKey);
        } catch (Exception $e) {
            error_log("Error checking user hash block: " . $e->getMessage());
            return false;
        }
    }
    
    private function blockUserHash($reason = 'Bot behavior detected') {
        try {
            $userHash = $this->generateUserHash();
            $ip = $this->getRealIP();
            
            $blockData = [
                'user_hash' => $userHash,
                'ip' => $ip,
                'blocked_at' => time(),
                'blocked_reason' => $reason,
                'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? '',
                'session_id' => 'no_session',
                'uri' => $_SERVER['REQUEST_URI'] ?? '',
                'headers' => $this->collectHeaders(),
                'browser_info' => $this->getBrowserFingerprint($_SERVER['HTTP_USER_AGENT'] ?? ''),
                'device_type' => 'unknown' // isMobileDevice() removed in optimization
            ];
            
            $blockKey = $this->userHashPrefix . 'blocked:' . $userHash;
            $this->redis->setex($blockKey, $this->ttlSettings['user_hash_blocked'], $blockData);
            
            $statsKey = $this->userHashPrefix . 'stats:' . $userHash;
            $this->redis->hincrby($statsKey, 'block_count', 1);
            $this->redis->hset($statsKey, 'last_blocked', time());
            $this->redis->hset($statsKey, 'last_blocked_reason', $reason);
            $this->redis->expire($statsKey, $this->ttlSettings['user_hash_stats']);
            
            error_log("Bot blocked [HASH]: " . substr($userHash, 0, 8) . " | IP: $ip | " . $blockData['device_type'] . " | " . $reason);
        } catch (Exception $e) {
            error_log("Error blocking user hash: " . $e->getMessage());
        }
    }
    
    private function trackUserHashActivity() {
        try {
            $userHash = $this->generateUserHash();
            $trackingKey = $this->userHashPrefix . 'tracking:' . $userHash;
            
            $existing = $this->redis->get($trackingKey);
            
            if ($existing) {
                $existing['requests']++;
                $existing['last_activity'] = time();
                
                $currentPage = parse_url($_SERVER['REQUEST_URI'] ?? '', PHP_URL_PATH);
                if (!in_array($currentPage, $existing['pages'])) {
                    $existing['pages'][] = $currentPage;
                }
                
                $existing['request_times'][] = time();
                
                $currentIP = $this->getRealIP();
                if (!in_array($currentIP, $existing['ips'])) {
                    $existing['ips'][] = $currentIP;
                }
                
                if (count($existing['request_times']) > 30) {
                    $existing['request_times'] = array_slice($existing['request_times'], -30);
                }
                if (count($existing['pages']) > 50) {
                    $existing['pages'] = array_unique(array_slice($existing['pages'], -50));
                }
                if (count($existing['ips']) > 15) {
                    $existing['ips'] = array_unique(array_slice($existing['ips'], -15));
                }
                
                $this->redis->setex($trackingKey, $this->ttlSettings['user_hash_tracking'], $existing);
                return $existing;
            } else {
                $data = [
                    'user_hash' => $userHash,
                    'first_seen' => time(),
                    'last_activity' => time(),
                    'requests' => 1,
                    'pages' => [parse_url($_SERVER['REQUEST_URI'] ?? '', PHP_URL_PATH)],
                    'ips' => [$this->getRealIP()],
                    'user_agents' => [$_SERVER['HTTP_USER_AGENT'] ?? ''],
                    'request_times' => [time()],
                    'browser_info' => $this->getBrowserFingerprint($_SERVER['HTTP_USER_AGENT'] ?? '')
                ];
                
                $this->redis->setex($trackingKey, $this->ttlSettings['user_hash_tracking'], $data);
                return $data;
            }
        } catch (Exception $e) {
            error_log("Error tracking user hash: " . $e->getMessage());
            return [];
        }
    }
    
    // analyzeSlowBot() removed in optimization (saved 107 lines)
    
    // enableExtendedTracking() removed in optimization (saved 19 lines)
    
    // checkExtendedTracking() removed in optimization (saved 9 lines)
    
    private function getUserTrackingData($ip) {
        try {
            $trackingKey = $this->trackingPrefix . 'ip:' . hash('md5', $ip);
            return $this->redis->get($trackingKey);
        } catch (Exception $e) {
            error_log("Error getting user tracking data: " . $e->getMessage());
            return null;
        }
    }
    
    /**
     * ═══════════════════════════════════════════════════════════════════════
     * ОБНОВЛЕНО v2.5: isPotentialSlowBot с более агрессивными проверками
     * 
     * Изменения:
     * - Порог снижен с 5 до 3 запросов
     * - Добавлена проверка отсутствия cookie
     * - Ужесточена проверка заголовков
     * ═══════════════════════════════════════════════════════════════════════
     */
    private function isPotentialSlowBot($trackingData) {
        // v2.5: Снижен порог с 5 до 3
        if (!$trackingData || $trackingData['requests'] < 3) {
            return false;
        }
        
        $timeSpent = time() - ($trackingData['first_seen'] ?? time());
        $requests = $trackingData['requests'];
        $headers = $this->collectHeaders();
        
        // v2.5: НОВОЕ - нет Accept-Language = очень подозрительно
        $acceptLang = $headers['HTTP_ACCEPT_LANGUAGE'] ?? '';
        if (empty($acceptLang) && $requests >= 3) {
            return true;
        }
        
        // v2.5: НОВОЕ - Accept: */* без других признаков браузера
        $accept = $headers['HTTP_ACCEPT'] ?? '';
        if ($accept === '*/*' && empty($headers['HTTP_SEC_FETCH_MODE']) && $requests >= 3) {
            return true;
        }
        
        // Долгая сессия с умеренным количеством запросов
        if ($timeSpent > ($this->slowBotSettings['long_session_hours'] * 3600) && 
            $requests > 10 && $requests < 100) {
            return true;
        }
        
        // Регулярные интервалы между запросами (роботы делают запросы "по таймеру")
        // v2.5: Снижен порог с 8 до 5 запросов
        if (isset($trackingData['request_times']) && count($trackingData['request_times']) >= 5) {
            $times = $trackingData['request_times'];
            $intervals = [];
            
            for ($i = 1; $i < count($times); $i++) {
                $intervals[] = $times[$i] - $times[$i-1];
            }
            
            if (count($intervals) >= 4) {
                $avgInterval = array_sum($intervals) / count($intervals);
                $variance = 0;
                foreach ($intervals as $interval) {
                    $variance += pow($interval - $avgInterval, 2);
                }
                $variance /= count($intervals);
                
                // Малая дисперсия = регулярные запросы = бот
                if ($variance < $this->slowBotSettings['suspicious_regularity_variance'] && 
                    $avgInterval > 30 && $avgInterval < 900) {  // v2.5: расширен диапазон
                    return true;
                }
            }
        }
        
        // Отсутствие критических заголовков после некоторого времени
        // v2.5: Снижен порог с 8 до 5 запросов
        if ($timeSpent > 1800 && $requests > 5) {  // 30 минут вместо 1 часа
            $missingHeaders = 0;
            
            if (!isset($headers['HTTP_REFERER'])) $missingHeaders++;
            if (!isset($headers['HTTP_ACCEPT_LANGUAGE'])) $missingHeaders += 2;  // v2.5: больший вес
            if (($headers['HTTP_ACCEPT'] ?? '') === '*/*') $missingHeaders++;
            if (!isset($headers['HTTP_SEC_FETCH_MODE'])) $missingHeaders++;
            
            if ($missingHeaders >= 2) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * ═══════════════════════════════════════════════════════════════════════
     * НОВЫЙ МЕТОД v2.4: Получить общее количество violations для IP
     * Объединяет rate limit violations + burst violations
     * ═══════════════════════════════════════════════════════════════════════
     */
    private function getTotalViolations($ip) {
        try {
            $violationsKey = $this->trackingPrefix . 'violations:' . hash('md5', $ip);
            $data = $this->redis->get($violationsKey);
            
            if (!$data || !is_array($data)) {
                return [
                    'rate_limit' => 0,
                    'burst' => 0,
                    'total' => 0,
                    'last_violation' => null
                ];
            }
            
            return [
                'rate_limit' => (int)($data['rate_limit'] ?? 0),
                'burst' => (int)($data['burst'] ?? 0),
                'total' => (int)($data['rate_limit'] ?? 0) + (int)($data['burst'] ?? 0),
                'last_violation' => $data['last_violation'] ?? null
            ];
        } catch (Exception $e) {
            error_log("Error getting total violations: " . $e->getMessage());
            return ['rate_limit' => 0, 'burst' => 0, 'total' => 0, 'last_violation' => null];
        }
    }
    
    /**
     * НОВЫЙ МЕТОД v2.4: Увеличить счётчик violations
     */
    private function incrementViolations($ip, $type = 'rate_limit') {
        try {
            $violationsKey = $this->trackingPrefix . 'violations:' . hash('md5', $ip);
            $data = $this->redis->get($violationsKey);
            
            if (!$data || !is_array($data)) {
                $data = [
                    'rate_limit' => 0,
                    'burst' => 0,
                    'ip' => $ip,
                    'first_violation' => time()
                ];
            }
            
            if ($type === 'rate_limit') {
                $data['rate_limit'] = (int)($data['rate_limit'] ?? 0) + 1;
            } elseif ($type === 'burst') {
                $data['burst'] = (int)($data['burst'] ?? 0) + 1;
            }
            
            $data['last_violation'] = time();
            $data['last_type'] = $type;
            
            // TTL 1 час - violations сбрасываются если пользователь "успокоился"
            $this->redis->setex($violationsKey, 3600, $data);
            
            return [
                'rate_limit' => (int)$data['rate_limit'],
                'burst' => (int)$data['burst'],
                'total' => (int)$data['rate_limit'] + (int)$data['burst']
            ];
        } catch (Exception $e) {
            error_log("Error incrementing violations: " . $e->getMessage());
            return ['rate_limit' => 0, 'burst' => 0, 'total' => 0];
        }
    }
    
    /**
     * НОВЫЙ МЕТОД v2.4: Сброс violations для IP
     */
    public function resetViolations($ip) {
        try {
            $violationsKey = $this->trackingPrefix . 'violations:' . hash('md5', $ip);
            $this->redis->del($violationsKey);
            return true;
        } catch (Exception $e) {
            return false;
        }
    }
    
    /**
     * НОВЫЙ МЕТОД v2.4: Получить статус violations для IP
     */
    public function getViolationsStatus($ip) {
        $violations = $this->getTotalViolations($ip);
        
        return [
            'ip' => $ip,
            'violations' => $violations,
            'thresholds' => [
                'rate_limit_api_block' => $this->rateLimitSettings['rate_limit_api_block_threshold'],
                'burst_api_block' => $this->rateLimitSettings['burst_api_block_threshold'],
                'combined_api_block' => $this->rateLimitSettings['combined_api_block_threshold'],
            ],
            'will_block_api' => $this->shouldBlockViaAPI($violations)
        ];
    }
    
    /**
     * НОВЫЙ МЕТОД v2.4: Проверить, нужно ли блокировать через API
     */
    private function shouldBlockViaAPI($violations) {
        // Проверяем каждый порог
        if ($violations['rate_limit'] >= $this->rateLimitSettings['rate_limit_api_block_threshold']) {
            return ['block' => true, 'reason' => 'rate_limit_threshold'];
        }
        
        if ($violations['burst'] >= $this->rateLimitSettings['burst_api_block_threshold']) {
            return ['block' => true, 'reason' => 'burst_threshold'];
        }
        
        if ($violations['total'] >= $this->rateLimitSettings['combined_api_block_threshold']) {
            return ['block' => true, 'reason' => 'combined_threshold'];
        }
        
        return ['block' => false, 'reason' => null];
    }
    
    // analyzeUserHashBehavior() removed in optimization (saved 12 lines)
    
    // performStandardUserHashAnalysis() removed in optimization (saved 90 lines)
    
    /**
     * НОВЫЙ МЕТОД: Проверка rate limit для rDNS
     */
    private function checkRDNSRateLimit() {
        try {
            $currentMinute = floor(time() / 60); // Текущая минута
            $rateLimitKey = $this->rdnsPrefix . 'ratelimit:' . $currentMinute;
            
            $currentCount = $this->redis->get($rateLimitKey);
            
            if ($currentCount === false) {
                // Первый запрос в эту минуту
                $this->redis->setex($rateLimitKey, 120, 1); // TTL 2 минуты для безопасности
                return ['allowed' => true, 'count' => 1, 'limit' => $this->rdnsLimitSettings['max_rdns_per_minute']];
            }
            
            $currentCount = (int)$currentCount;
            
            if ($currentCount >= $this->rdnsLimitSettings['max_rdns_per_minute']) {
                // Лимит превышен
                error_log("rDNS rate limit exceeded: $currentCount/{$this->rdnsLimitSettings['max_rdns_per_minute']} in current minute");
                return [
                    'allowed' => false,
                    'count' => $currentCount,
                    'limit' => $this->rdnsLimitSettings['max_rdns_per_minute'],
                    'reason' => 'rDNS rate limit exceeded'
                ];
            }
            
            // Инкрементируем счетчик
            $this->redis->incr($rateLimitKey);
            
            return [
                'allowed' => true,
                'count' => $currentCount + 1,
                'limit' => $this->rdnsLimitSettings['max_rdns_per_minute']
            ];
            
        } catch (Exception $e) {
            error_log("Error in checkRDNSRateLimit: " . $e->getMessage());
            // При ошибке - разрешаем проверку
            return ['allowed' => true, 'count' => 0, 'limit' => $this->rdnsLimitSettings['max_rdns_per_minute']];
        }
    }
    
    /**
     * Получить статистику rDNS rate limit
     */
    /**
     * УЛУЧШЕННАЯ версия: использует SCAN вместо KEYS для неблокирующей работы
     */
    public function getRDNSRateLimitStats() {
        try {
            $currentMinute = floor(time() / 60);
            $prevMinute = $currentMinute - 1;
            
            $currentKey = $this->rdnsPrefix . 'ratelimit:' . $currentMinute;
            $prevKey = $this->rdnsPrefix . 'ratelimit:' . $prevMinute;
            
            $currentCount = $this->redis->get($currentKey) ?: 0;
            $prevCount = $this->redis->get($prevKey) ?: 0;
            
            // УЛУЧШЕНИЕ: Используем SCAN вместо KEYS (не блокирует Redis)
            $cacheCount = 0;
            $verifiedCount = 0;
            $notVerifiedCount = 0;
            $sampleSize = 100; // Проверяем максимум 100 записей для статистики
            $sampled = 0;
            
            $iterator = null;
            // ВАЖНО: OPT_PREFIX НЕ применяется к паттернам SCAN - указываем полный путь
            $pattern = $this->redisPrefix . $this->rdnsPrefix . 'cache:*';
            
            while (true) {
                $keys = $this->redis->scan($iterator, $pattern, 50);
                
                if ($keys === false) {
                    break;
                }
                
                $cacheCount += count($keys);
                
                // Проверяем только первые $sampleSize записей
                if ($sampled < $sampleSize) {
                    foreach ($keys as $key) {
                        if ($sampled >= $sampleSize) break;
                        
                        // SCAN возвращает полный путь, убираем redisPrefix для get()
                        $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                        $data = $this->redis->get($keyWithoutPrefix);
                        if ($data && isset($data['verified'])) {
                            if ($data['verified']) {
                                $verifiedCount++;
                            } else {
                                $notVerifiedCount++;
                            }
                        }
                        $sampled++;
                    }
                }
                
                if ($iterator === 0) {
                    break;
                }
            }
            
            return [
                'current_minute_requests' => (int)$currentCount,
                'previous_minute_requests' => (int)$prevCount,
                'limit_per_minute' => $this->rdnsLimitSettings['max_rdns_per_minute'],
                'cache_entries' => $cacheCount,
                'verified_in_cache' => $verifiedCount,
                'not_verified_in_cache' => $notVerifiedCount,
                'limit_reached' => $currentCount >= $this->rdnsLimitSettings['max_rdns_per_minute'],
                'settings' => $this->rdnsLimitSettings
            ];
            
        } catch (Exception $e) {
            error_log("Error getting rDNS stats: " . $e->getMessage());
            return [];
        }
    }
    
    /**
     * УЛУЧШЕННАЯ версия: использует SCAN вместо KEYS для неблокирующей очистки
     */
    public function clearRDNSCache() {
        try {
            $deleted = 0;
            $iterator = null;
            // ВАЖНО: OPT_PREFIX НЕ применяется к паттернам SCAN - указываем полный путь
            $pattern = $this->redisPrefix . $this->rdnsPrefix . 'cache:*';
            
            while (true) {
                $keys = $this->redis->scan($iterator, $pattern, 100);
                
                if ($keys === false) {
                    break;
                }
                
                foreach ($keys as $key) {
                    // SCAN возвращает полный путь, убираем redisPrefix для del()
                    $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                    $this->redis->del($keyWithoutPrefix);
                    $deleted++;
                }
                
                if ($iterator === 0) {
                    break;
                }
            }
            
            error_log("Cleared rDNS cache: $deleted entries");
            return $deleted;
            
        } catch (Exception $e) {
            error_log("Error clearing rDNS cache: " . $e->getMessage());
            return 0;
        }
    }
    
    /**
     * НОВЫЙ МЕТОД: Очистка whitelist поисковиков (вызывается из cleanup.php)
     */
    public function clearSearchEngineWhitelist() {
        try {
            $deleted = 0;
            $iterator = null;
            // ВАЖНО: OPT_PREFIX НЕ применяется к паттернам SCAN - указываем полный путь
            $pattern = $this->redisPrefix . $this->rdnsPrefix . 'whitelist:*';
            
            while (true) {
                $keys = $this->redis->scan($iterator, $pattern, 100);
                
                if ($keys === false) {
                    break;
                }
                
                foreach ($keys as $key) {
                    // SCAN возвращает полный путь, убираем redisPrefix для del()
                    $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                    $this->redis->del($keyWithoutPrefix);
                    $deleted++;
                }
                
                if ($iterator === 0) {
                    break;
                }
            }
            
            error_log("Cleared search engine whitelist: $deleted entries");
            return $deleted;
            
        } catch (Exception $e) {
            error_log("Error clearing whitelist: " . $e->getMessage());
            return 0;
        }
    }
    
    /**
     * Сбросить счетчики rDNS rate limit
     */
    public function resetRDNSRateLimit() {
        try {
            $currentMinute = floor(time() / 60);
            $rateLimitKey = $this->rdnsPrefix . 'ratelimit:' . $currentMinute;
            
            $result = $this->redis->del($rateLimitKey);
            error_log("rDNS rate limit reset for current minute");
            
            return $result > 0;
            
        } catch (Exception $e) {
            error_log("Error resetting rDNS rate limit: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Обновить настройки rDNS rate limiting
     */
    public function updateRDNSSettings($newSettings) {
        $this->rdnsLimitSettings = array_merge($this->rdnsLimitSettings, $newSettings);
        error_log("rDNS settings updated: " . json_encode($newSettings));
    }
    
    /**
     * Получить настройки rDNS
     */
    public function getRDNSSettings() {
        return $this->rdnsLimitSettings;
    }
    
    /**
     * РАБОЧИЙ Rate Limit v2.3.2 (добавлено сохранение IP в данные)
     * 
     * Вариант B: Мягче для пользователей с валидным cookie
     * - Пользователи с cookie: лимиты × cookie_multiplier (по умолчанию ×2)
     * - Пользователи без cookie: стандартные лимиты
     * 
     * @param string $ip IP адрес
     * @param bool $hasCookie Есть ли валидный cookie
     * @return array Результат проверки
     */
    private function checkRateLimit($ip, $hasCookie = false) {
        // Проверяем исключен ли текущий URL из проверок
        if ($this->isExcludedFromJSChallenge()) {
            return [
                'allowed' => true,
                'reason' => 'URL excluded from rate limit checks',
                'excluded' => true
            ];
        }
        
        try {
            $now = time();
            
            // Ключ для этого IP
            $key = $this->trackingPrefix . 'rl:' . hash('md5', $ip);
            
            // Получаем данные из Redis
            $data = $this->redis->get($key);
            
            // Текущие временные окна
            $minuteWindow = floor($now / 60);
            $fiveMinWindow = floor($now / 300);
            $hourWindow = floor($now / 3600);
            
            // Инициализация счётчиков
            $counts = [
                'min' => 0,
                'min5' => 0,
                'hour' => 0,
                'min_window' => $minuteWindow,
                'min5_window' => $fiveMinWindow,
                'hour_window' => $hourWindow,
                'violations' => 0,
                'ip' => $ip  // Сохраняем IP для отображения в админке
            ];
            
            // Если есть данные - восстанавливаем счётчики для текущих окон
            if ($data && is_array($data)) {
                // Минута - если окно совпадает, берём счётчик
                if (isset($data['min_window']) && $data['min_window'] == $minuteWindow) {
                    $counts['min'] = (int)($data['min'] ?? 0);
                }
                // 5 минут
                if (isset($data['min5_window']) && $data['min5_window'] == $fiveMinWindow) {
                    $counts['min5'] = (int)($data['min5'] ?? 0);
                }
                // Час
                if (isset($data['hour_window']) && $data['hour_window'] == $hourWindow) {
                    $counts['hour'] = (int)($data['hour'] ?? 0);
                }
                // Нарушения
                $counts['violations'] = (int)($data['violations'] ?? 0);
                // IP сохраняем всегда текущий
                $counts['ip'] = $ip;
            }
            
            // Инкрементируем ВСЕ счётчики
            $counts['min']++;
            $counts['min5']++;
            $counts['hour']++;
            
            // Определяем лимиты (с множителем для cookie)
            $multiplier = $hasCookie ? $this->rateLimitSettings['cookie_multiplier'] : 1.0;
            $limits = [
                'min' => (int)($this->rateLimitSettings['max_requests_per_minute'] * $multiplier),
                'min5' => (int)($this->rateLimitSettings['max_requests_per_5min'] * $multiplier),
                'hour' => (int)($this->rateLimitSettings['max_requests_per_hour'] * $multiplier),
            ];
            
            // Проверяем превышения
            $exceeded = [];
            if ($counts['min'] > $limits['min']) {
                $exceeded[] = "1min({$counts['min']}/{$limits['min']})";
            }
            if ($counts['min5'] > $limits['min5']) {
                $exceeded[] = "5min({$counts['min5']}/{$limits['min5']})";
            }
            if ($counts['hour'] > $limits['hour']) {
                $exceeded[] = "1hour({$counts['hour']}/{$limits['hour']})";
            }
            
            // Если есть превышение - инкрементируем violations
            if (!empty($exceeded)) {
                $counts['violations']++;
            }
            
            // Сохраняем в Redis (TTL 1 час)
            $this->redis->setex($key, 3600, $counts);
            
            // Формируем ответ
            if (!empty($exceeded)) {
                return [
                    'allowed' => false,
                    'reason' => 'Rate limit exceeded: ' . implode(', ', $exceeded),
                    'exceeded' => $exceeded,
                    'violation_count' => $counts['violations'],
                    'has_cookie' => $hasCookie,
                    'multiplier' => $multiplier,
                    'stats' => [
                        '1min' => $counts['min'],
                        '5min' => $counts['min5'],
                        '1hour' => $counts['hour'],
                    ],
                    'limits' => $limits
                ];
            }
            
            return [
                'allowed' => true,
                'reason' => null,
                'violation_count' => $counts['violations'],
                'has_cookie' => $hasCookie,
                'stats' => [
                    '1min' => $counts['min'],
                    '5min' => $counts['min5'],
                    '1hour' => $counts['hour'],
                ],
                'limits' => $limits
            ];
            
        } catch (Exception $e) {
            error_log("checkRateLimit ERROR: " . $e->getMessage());
            return ['allowed' => true, 'reason' => null, 'violation_count' => 0];
        }
    }
    
    /**
     * Сброс rate limit для IP (например, после разблокировки)
     * v2.3: Теперь просто удаляем один ключ
     */
    public function resetRateLimit($ip) {
        try {
            $rateLimitKey = $this->trackingPrefix . 'rl:' . hash('md5', $ip);
            $this->redis->del($rateLimitKey);
            return true;
        } catch (Exception $e) {
            error_log("Error resetting rate limit: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Получить текущий статус rate limit для IP
     */
    public function getRateLimitStatus($ip) {
        try {
            $key = $this->trackingPrefix . 'rl:' . hash('md5', $ip);
            $data = $this->redis->get($key);
            
            if (!$data || !is_array($data)) {
                return [
                    'exists' => false,
                    'message' => 'No rate limit data for this IP'
                ];
            }
            
            $now = time();
            $minuteWindow = floor($now / 60);
            $fiveMinWindow = floor($now / 300);
            $hourWindow = floor($now / 3600);
            
            // Определяем актуальные счётчики (те что в текущем окне)
            $currentCounts = [
                '1min' => (isset($data['min_window']) && $data['min_window'] == $minuteWindow) ? $data['min'] : 0,
                '5min' => (isset($data['min5_window']) && $data['min5_window'] == $fiveMinWindow) ? $data['min5'] : 0,
                '1hour' => (isset($data['hour_window']) && $data['hour_window'] == $hourWindow) ? $data['hour'] : 0,
            ];
            
            return [
                'exists' => true,
                'ip' => $ip,
                'current_counts' => $currentCounts,
                'limits_no_cookie' => [
                    '1min' => $this->rateLimitSettings['max_requests_per_minute'],
                    '5min' => $this->rateLimitSettings['max_requests_per_5min'],
                    '1hour' => $this->rateLimitSettings['max_requests_per_hour'],
                ],
                'limits_with_cookie' => [
                    '1min' => (int)($this->rateLimitSettings['max_requests_per_minute'] * $this->rateLimitSettings['cookie_multiplier']),
                    '5min' => (int)($this->rateLimitSettings['max_requests_per_5min'] * $this->rateLimitSettings['cookie_multiplier']),
                    '1hour' => (int)($this->rateLimitSettings['max_requests_per_hour'] * $this->rateLimitSettings['cookie_multiplier']),
                ],
                'violations' => (int)($data['violations'] ?? 0),
                'raw_data' => $data
            ];
        } catch (Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }
    
    /**
     * Тест rate limit - симулирует N запросов
     * @param string $ip IP адрес для теста
     * @param int $numRequests Количество запросов для симуляции
     * @param bool $withCookie Симулировать с cookie или без
     */
    // testRateLimit() removed in optimization (saved 47 lines)
    
    /**
     * НОВЫЙ МЕТОД v2.3: Миграция со старой версии
     * Удаляет старые rate limit ключи формата rl:1m:*, rl:5m:*, rl:1h:*, grl:*:*
     * Запустить ОДИН раз после обновления!
     */
    // migrateFromOldRateLimitKeys() removed in optimization (saved 54 lines)
    
    /**
     * НОВЫЙ МЕТОД v2.3: Получить статистику использования ключей
     * Помогает диагностировать проблемы с памятью
     */
    // getKeyStats() removed in optimization (saved 45 lines)
    
    /**
     * НОВЫЙ МЕТОД: Детекция всплесков активности
     */
    /**
     * РАБОЧИЙ Burst Detection v2.3.1
     * 
     * Детектирует всплески активности: слишком много запросов за короткое время
     * Использует отдельный ключ для надёжности
     * 
     * Вариант B: пользователи с cookie получают увеличенный порог (×cookie_multiplier)
     * 
     * @param string $ip IP адрес
     * @param bool $hasCookie Есть ли валидный cookie
     * @return array|false Информация о всплеске или false
     */
    private function detectBurst($ip, $hasCookie = false) {
        // Проверяем исключен ли текущий URL из проверок
        if ($this->isExcludedFromJSChallenge()) {
            return [
                'detected' => false,
                'reason' => 'URL excluded from burst detection',
                'excluded' => true
            ];
        }
        
        try {
            $now = time();
            $window = $this->rateLimitSettings['burst_window'];  // 10 сек
            
            // Порог с учётом cookie
            $multiplier = $hasCookie ? $this->rateLimitSettings['cookie_multiplier'] : 1.0;
            $threshold = (int)($this->rateLimitSettings['burst_threshold'] * $multiplier);
            
            // Отдельный ключ для burst detection
            $burstKey = $this->trackingPrefix . 'burst:' . hash('md5', $ip);
            
            // Получаем данные
            $data = $this->redis->get($burstKey);
            
            // Инициализация
            $requests = [];
            
            if ($data && is_array($data) && isset($data['times'])) {
                // Фильтруем только запросы в текущем окне
                $requests = array_filter($data['times'], function($time) use ($now, $window) {
                    return ($now - $time) <= $window;
                });
                // Переиндексируем массив
                $requests = array_values($requests);
            }
            
            // Добавляем текущий запрос
            $requests[] = $now;
            
            // Ограничиваем размер массива (храним только последние N*2 запросов)
            $maxStore = max($threshold * 2, 20);
            if (count($requests) > $maxStore) {
                $requests = array_slice($requests, -$maxStore);
            }
            
            // Проверяем порог ПЕРЕД сохранением, чтобы определить TTL
            $requestsInWindow = count(array_filter($requests, function($time) use ($now, $window) {
                return ($now - $time) <= $window;
            }));
            
            // Если превысили порог - увеличиваем TTL до 1 часа для показа в админке
            // Иначе - короткий TTL (окно * 2)
            $ttl = ($requestsInWindow > $threshold) ? 3600 : ($window * 2);
            
            // Сохраняем с адаптивным TTL - добавляем IP для отображения в админке
            $this->redis->setex($burstKey, $ttl, [
                'times' => $requests, 
                'ip' => $ip,
                'exceeded' => ($requestsInWindow > $threshold) // Маркер превышения
            ]);
            
            if ($requestsInWindow > $threshold) {
                return [
                    'detected' => true,
                    'requests_in_window' => $requestsInWindow,
                    'threshold' => $threshold,
                    'window' => $window,
                    'has_cookie' => $hasCookie,
                    'multiplier' => $multiplier,
                    'message' => "$requestsInWindow requests in {$window}s (limit: $threshold)"
                ];
            }
            
            return false;
            
        } catch (Exception $e) {
            error_log("detectBurst ERROR: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Сброс burst detection для IP
     */
    public function resetBurst($ip) {
        try {
            $burstKey = $this->trackingPrefix . 'burst:' . hash('md5', $ip);
            $this->redis->del($burstKey);
            return true;
        } catch (Exception $e) {
            return false;
        }
    }
    
    /**
     * Получить статус burst для IP
     */
    public function getBurstStatus($ip, $hasCookie = false) {
        try {
            $now = time();
            $window = $this->rateLimitSettings['burst_window'];
            $multiplier = $hasCookie ? $this->rateLimitSettings['cookie_multiplier'] : 1.0;
            $threshold = (int)($this->rateLimitSettings['burst_threshold'] * $multiplier);
            
            $burstKey = $this->trackingPrefix . 'burst:' . hash('md5', $ip);
            $data = $this->redis->get($burstKey);
            
            if (!$data || !is_array($data) || !isset($data['times'])) {
                return [
                    'exists' => false,
                    'requests_in_window' => 0,
                    'threshold' => $threshold,
                    'window' => $window,
                    'has_cookie' => $hasCookie
                ];
            }
            
            $requestsInWindow = count(array_filter($data['times'], function($time) use ($now, $window) {
                return ($now - $time) <= $window;
            }));
            
            return [
                'exists' => true,
                'requests_in_window' => $requestsInWindow,
                'threshold' => $threshold,
                'window' => $window,
                'has_cookie' => $hasCookie,
                'will_block_next' => $requestsInWindow >= $threshold,
                'raw_times' => $data['times']
            ];
        } catch (Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }
    
    /**
     * Тест burst detection
     * @param string $ip IP для теста
     * @param int $numRequests Количество запросов
     * @param int $delayMs Задержка между запросами в миллисекундах
     * @param bool $withCookie Симулировать с cookie или без
     */
    // testBurst() removed in optimization (saved 43 lines)
    
    /**
     * НОВЫЙ МЕТОД: Детекция смены User-Agent
     */
    private function detectUserAgentSwitching($ip) {
        try {
            $trackingKey = $this->trackingPrefix . 'ip:' . hash('md5', $ip);
            $data = $this->redis->get($trackingKey);
            
            if (!$data) {
                return false;
            }
            
            $uniqueUA = array_unique($data['user_agents'] ?? []);
            $uaCount = count($uniqueUA);
            
            if ($uaCount >= $this->rateLimitSettings['ua_change_threshold']) {
                $timeSpent = time() - ($data['first_seen'] ?? time());
                
                if ($timeSpent < $this->rateLimitSettings['ua_change_time_window']) {
                    return [
                        'detected' => true,
                        'unique_ua_count' => $uaCount,
                        'time_window' => $timeSpent,
                        'threshold' => $this->rateLimitSettings['ua_change_threshold'],
                        'user_agents' => array_map(function($ua) {
                            return substr($ua, 0, 50) . '...';
                        }, $uniqueUA)
                    ];
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            error_log("Error in detectUserAgentSwitching: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * НОВЫЙ МЕТОД: Прогрессивная блокировка
     */
    private function applyProgressiveBlock($ip, $reason, $violationData = null) {
    try {
        $blockKey = $this->blockPrefix . 'ip:' . hash('md5', $ip);
        $historyKey = $this->blockPrefix . 'history:' . hash('md5', $ip);
        
        $history = $this->redis->get($historyKey) ?: ['count' => 0, 'last_block' => 0];
        $history['count']++;
        $history['last_block'] = time();
        
        $blockDuration = $this->rateLimitSettings['progressive_block_duration'];
        
        if ($history['count'] >= 3) {
            $blockDuration = $this->rateLimitSettings['aggressive_block_duration'] * $history['count'];
        }
        
        $blockData = [
            'ip' => $ip,
            'blocked_at' => time(),
            'blocked_reason' => $reason,
            'violation_count' => $history['count'],
            'block_duration' => $blockDuration,
            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? '',
            'uri' => $_SERVER['REQUEST_URI'] ?? '',
            'violation_data' => $violationData,
            'api_blocked' => false
        ];
        
        // Блокировка в Redis
        if ($this->apiSettings['block_on_redis']) {
            $this->redis->setex($blockKey, $blockDuration, $blockData);
            $this->redis->setex($historyKey, 86400 * 7, $history);
        }
        
		// НОВАЯ ПРОВЕРКА: Защита от повторных вызовов API
$apiCallKey = $this->blockPrefix . 'api_call:' . hash('md5', $ip);
$recentApiCall = $this->redis->get($apiCallKey);

if ($recentApiCall) {
    // API уже вызывался в последние 60 секунд - пропустить
    error_log("Skipping duplicate API call for $ip");
    $skipApiCall = true;
} else {
    $skipApiCall = false;
}
		
        // Блокировка через API
        if ($this->apiSettings['block_on_api'] && !$skipApiCall) {
            $apiResult = $this->callBlockingAPI($ip, 'block');
            
            if ($apiResult['status'] === 'success' || $apiResult['status'] === 'already_blocked') {
				$this->redis->setex($apiCallKey, 60, time()); // Защита на 60 секунд
                $blockData['api_blocked'] = true;
                $blockData['api_result'] = $apiResult['message'];
                
                if ($this->apiSettings['block_on_redis']) {
                    $this->redis->setex($blockKey, $blockDuration, $blockData);
                }
            }
        }
        
        $hours = round($blockDuration / 3600, 1);
        $apiStatus = $blockData['api_blocked'] ? 'API+Redis' : 'Redis only';
        error_log("RATE LIMIT BLOCK: $ip | {$apiStatus} | Count: {$history['count']} | Duration: {$hours}h | $reason");
        
        return true;
        
    } catch (Exception $e) {
        error_log("Error in applyProgressiveBlock: " . $e->getMessage());
        return false;
    }
}
    
    /**
     * ОБНОВЛЕННЫЙ МЕТОД protect() с rate limiting
     */
    /**
     * ═══════════════════════════════════════════════════════════════════════
     * ОБНОВЛЕННЫЙ МЕТОД protect() v2.4
     * 
     * КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: Rate Limit и Burst Detection проверяются ВСЕГДА,
     * даже когда показывается 429 ошибка. При достижении порога violations
     * IP автоматически блокируется через API.
     * ═══════════════════════════════════════════════════════════════════════
     */
    public function protect() {
        // Инкрементируем счётчик запросов для статистики RPM/RPS
        $this->incrementRequestCounter();
        
        if ($this->isStaticFile()) {
            return;
        }
        
        // ВЕРОЯТНОСТНАЯ ПРОВЕРКА переполнения Redis (не каждый запрос!)
        if (rand(1, $this->globalProtectionSettings['cleanup_probability']) === 1) {
            $this->manageTrackedIPs();
        }
        
        $ip = $this->getRealIP();
        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? '';
        
        // ═══════════════════════════════════════════════════════════════════
        // Глобальный rate limit ДО проверки ботов
        // ═══════════════════════════════════════════════════════════════════
        $globalRateLimit = $this->checkGlobalRateLimit($ip);
        if (!$globalRateLimit['allowed']) {
            error_log("GLOBAL RATE LIMIT: $ip | " . $globalRateLimit['requests'] . " req/sec");
            $this->blockIP($ip, 'Global rate limit exceeded (possible DDoS)');
            $this->sendBlockResponse();
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // КРИТИЧНО v2.5.4: EXCLUDED URLS - ПОЛНЫЙ ПРОПУСК ВСЕХ ПРОВЕРОК!
        // Исключённые URL должны проверяться ДО всех блокировок
        // Иначе они всё равно блокируются по cookie, user hash, и т.д.
        // ═══════════════════════════════════════════════════════════════════
        if ($this->isExcludedFromJSChallenge()) {
            // Логируем для отладки
            error_log("URL EXCLUDED FROM ALL CHECKS: $ip | URI: " . $_SERVER['REQUEST_URI']);
            return; // Полный пропуск всех проверок
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // CUSTOM IP WHITELIST v2.5.12 - ПОЛНЫЙ ПРОПУСК для IP из белого списка
        // Пропускает ВСЕ user agent без проверок!
        // IP из customIPWhitelist проходят без ЛЮБЫХ проверок
        // ═══════════════════════════════════════════════════════════════════
        if ($this->isCustomWhitelistedIP($ip)) {
            error_log("CUSTOM IP WHITELIST: $ip | Full bypass, all user agents allowed | UA: " . substr($userAgent, 0, 100));
            return; // Полный пропуск всех проверок
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // НОВОЕ v2.5.7: IP WHITELIST для поисковых ботов (CIDR поддержка)
        // Проверяем IP в whitelist ПЕРЕД rDNS для экономии времени
        // Поддержка IPv4 и IPv6 CIDR диапазонов
        // ═══════════════════════════════════════════════════════════════════
        $ipWhitelistResult = $this->isSearchEngineByIP($ip, $userAgent);
        if ($ipWhitelistResult) {
            // IP в whitelist поисковика
            $engine = $ipWhitelistResult['engine'];
            $range = $ipWhitelistResult['matched_range'];
            $method = $ipWhitelistResult['method'];
            
            error_log("SEARCH ENGINE IP WHITELIST: $ip | Engine: $engine | Range: $range | Method: $method | UA: " . substr($userAgent, 0, 100));
            
            // Добавляем в whitelist для быстрого доступа в будущем
            $this->addToSearchEngineWhitelist($ip, $userAgent);
            $this->logSearchEngineVisit($ip, $userAgent);
            
            return; // Полный пропуск проверок
        }
        
        // Проверка whitelist верифицированных поисковиков
        if ($this->isWhitelistedSearchEngine($ip)) {
            return;
        }
        
        if ($this->isLegitimateBot($userAgent)) {
            $this->logBotVisit($ip, $userAgent, 'legitimate');
            return;
        }
        
        if ($this->isVerifiedSearchEngine($ip, $userAgent)) {
            $this->addToSearchEngineWhitelist($ip, $userAgent);
            $this->logSearchEngineVisit($ip, $userAgent);
            return;
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // JS CHALLENGE PROTECTION v2.5.13 - ПЕРВАЯ ПРОВЕРКА ПОСЛЕ WHITELIST!
        // Проверяем нужно ли показать JS Challenge ПЕРЕД всеми остальными
        // проверками. Это гарантирует что боты получат challenge раньше,
        // чем смогут обойти другие проверки.
        // ═══════════════════════════════════════════════════════════════════
        if ($this->jsChallengeSettings['enabled']) {
            $jsChallengeResult = $this->checkJSChallenge($ip);
            
            if ($jsChallengeResult['show_challenge']) {
                error_log("JS CHALLENGE SHOWN (FIRST CHECK): $ip | Reason: {$jsChallengeResult['reason']}");
                $this->showJSChallenge($jsChallengeResult['reason']);
            }
        }
        
        if ($this->isUserHashBlocked()) {
            $this->sendBlockResponse();
        }
        
        if ($this->isCookieBlocked()) {
            $this->sendBlockResponse();
        }
        
        if ($this->isBlocked($ip) && $this->isSuspiciousUserAgent($userAgent)) {
            $this->sendBlockResponse();
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // RATE LIMIT + BURST ПРОВЕРКА (v2.5.13: Теперь ПОСЛЕ JS Challenge!)
        // Счётчики всё равно увеличиваются для отслеживания нагрузки
        // ═══════════════════════════════════════════════════════════════════
        $hasCookie = $this->hasValidCookie();
        
        // 1. Проверяем Rate Limit (счетчики ВСЕГДА увеличиваются)
        $rateLimitResult = $this->checkRateLimit($ip, $hasCookie);
        $rateLimitExceeded = !$rateLimitResult['allowed'];
        
        // 2. Проверяем Burst Detection (счетчики ВСЕГДА увеличиваются)
        $burstDetected = $this->detectBurst($ip, $hasCookie);
        $burstExceeded = $burstDetected && $burstDetected['detected'];
        
        // 3. Если есть нарушение - увеличиваем счётчик violations
        if ($rateLimitExceeded) {
            $violations = $this->incrementViolations($ip, 'rate_limit');
            $cookieInfo = $hasCookie ? ' [HAS_COOKIE, x' . ($rateLimitResult['multiplier'] ?? 1) . ']' : ' [NO_COOKIE]';
            error_log("RATE LIMIT EXCEEDED: $ip$cookieInfo | " . $rateLimitResult['reason'] . 
                     " | RL Violations: " . $violations['rate_limit'] . " | Total: " . $violations['total']);
        }
        
        if ($burstExceeded) {
            $violations = $this->incrementViolations($ip, 'burst');
            $cookieInfo = $hasCookie ? ' [HAS_COOKIE, x' . ($burstDetected['multiplier'] ?? 1) . ']' : ' [NO_COOKIE]';
            error_log("BURST DETECTED: $ip$cookieInfo | {$burstDetected['message']}" .
                     " | Burst Violations: " . $violations['burst'] . " | Total: " . $violations['total']);
        }
        
        // 4. Проверяем, нужно ли блокировать через API
        if ($rateLimitExceeded || $burstExceeded) {
            $violations = $this->getTotalViolations($ip);
            $shouldBlock = $this->shouldBlockViaAPI($violations);
            
            if ($shouldBlock['block']) {
                // Порог достигнут - блокируем через API!
                $blockReason = sprintf(
                    "API block triggered: %s (RL: %d/%d, Burst: %d/%d, Total: %d/%d)",
                    $shouldBlock['reason'],
                    $violations['rate_limit'],
                    $this->rateLimitSettings['rate_limit_api_block_threshold'],
                    $violations['burst'],
                    $this->rateLimitSettings['burst_api_block_threshold'],
                    $violations['total'],
                    $this->rateLimitSettings['combined_api_block_threshold']
                );
                
                error_log("API BLOCK TRIGGERED: $ip | $blockReason");
                
                $this->applyProgressiveBlock($ip, $blockReason, [
                    'rate_limit_result' => $rateLimitResult,
                    'burst_result' => $burstDetected,
                    'violations' => $violations,
                    'trigger' => $shouldBlock['reason']
                ]);
                $this->blockUserHash('API block: ' . $shouldBlock['reason']);
                $this->sendBlockResponse();
            } else {
                // Порог не достигнут - показываем 429 и продолжаем считать
                if ($rateLimitExceeded) {
                    $this->send429Response($ip, $violations, 'rate_limit', $rateLimitResult);
                } elseif ($burstExceeded) {
                    $this->send429Response($ip, $violations, 'burst', $burstDetected);
                }
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // АГРЕССИВНАЯ ДЕТЕКЦИЯ БОТОВ ПО HTTP ЗАГОЛОВКАМ
        // ═══════════════════════════════════════════════════════════════════
        if ($this->headerDetectionSettings['enabled']) {
            $headerCheck = $this->checkSuspiciousHeaders();
            if ($headerCheck['suspicious']) {
                $headerScore = $headerCheck['score'];
                $blockThreshold = $this->headerDetectionSettings['block_score_threshold'];
                $trackingThreshold = $this->headerDetectionSettings['tracking_score_threshold'];
                
                if ($headerScore >= $blockThreshold) {
                    $ajaxInfo = isset($headerCheck['is_ajax']) && $headerCheck['is_ajax'] ? ' [AJAX]' : '';
                    error_log("BOT BLOCKED BY HEADERS: $ip | Score: $headerScore$ajaxInfo | Missing: " . implode(', ', $headerCheck['missing']));
                    $this->applyProgressiveBlock($ip, 'Bot signature detected (missing headers, score: ' . $headerScore . ')');
                    $this->blockUserHash('Bot headers signature');
                    $this->sendBlockResponse();
                }
                
                if ($headerScore >= $trackingThreshold && $headerScore < $blockThreshold) {
                    $ajaxInfo = isset($headerCheck['is_ajax']) && $headerCheck['is_ajax'] ? ' [AJAX]' : '';
                    // $this->enableExtendedTracking($ip, 'Suspicious HTTP headers (score: ' . $headerScore . $ajaxInfo . ')');
                }
            }
        }
        
        // Детекция смены User-Agent
        $uaSwitching = $this->detectUserAgentSwitching($ip);
        if ($uaSwitching && $uaSwitching['detected']) {
            $this->applyProgressiveBlock($ip, 'User-Agent switching detected', $uaSwitching);
            $this->blockUserHash('UA switching');
            if (isset($_COOKIE[$this->cookieName])) {
                $this->blockCookieHash();
            }
            $this->sendBlockResponse();
        }
        
        $hasExtendedTracking = false /* checkExtendedTracking removed */;
        
        if ($hasCookie) {
            $this->trackUserHashActivity();
            
            if ($this->shouldAnalyzeIP($ip) || $hasExtendedTracking) {
                if ($this->analyzeRequest($ip)) {
                    if ($this->isSuspiciousUserAgent($userAgent)) {
                        $this->blockIP($ip, 'Suspicious user agent with valid cookie');
                        $this->blockCookieHash();
                        $this->blockUserHash('Bot with valid cookie');
                    } else {
                        $this->blockUserHash('Browser behavior detected with valid cookie');
                        $this->blockCookieHash();
                    }
                    $this->sendBlockResponse();
                }
            }
            return;
        }
        
        if ($this->shouldAnalyzeIP($ip) || $hasExtendedTracking) {
            if ($this->analyzeRequest($ip)) {
                if ($this->isSuspiciousUserAgent($userAgent)) {
                    $this->blockIP($ip, 'Suspicious user agent detected');
                    if (isset($_COOKIE[$this->cookieName])) {
                        $this->blockCookieHash();
                    }
                    $this->blockUserHash('Bot detected');
                } else {
                    if (!$hasExtendedTracking) {
                        // $this->enableExtendedTracking($ip, 'Suspicious browser behavior');
                    }
                    
                    if (isset($_COOKIE[$this->cookieName])) {
                        $this->blockCookieHash();
                    } else {
                        $this->blockUserHash('Browser behavior detected without cookie');
                    }
                }
                $this->sendBlockResponse();
            }
        }
        
        if (false /* analyzeUserHashBehavior removed */) {
            if ($this->isSuspiciousUserAgent($userAgent)) {
                $this->blockIP($ip, 'Bot behavior confirmed by user hash analysis');
                $this->blockUserHash('Bot confirmed');
                if (isset($_COOKIE[$this->cookieName])) {
                    $this->blockCookieHash();
                }
            } else {
                $this->blockUserHash('Slow bot behavior detected');
                if (isset($_COOKIE[$this->cookieName])) {
                    $this->blockCookieHash();
                }
            }
            
            $this->sendBlockResponse();
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // НОВОЕ v2.5: Блокировка если нет cookie после N запросов
        // Защита от распределённого парсинга (ботнеты с разных IP)
        // ═══════════════════════════════════════════════════════════════════
        if (!$hasCookie) {
            $trackingData = $this->getUserTrackingData($ip);
            $noCookieThreshold = $this->rateLimitSettings['no_cookie_block_threshold'] ?? 3;
            
            if ($trackingData && ($trackingData['requests'] ?? 0) >= $noCookieThreshold) {
                $requestCount = $trackingData['requests'];
                error_log("NO COOKIE BOT BLOCKED: $ip | Requests without cookie: $requestCount (threshold: $noCookieThreshold)");
                $this->applyProgressiveBlock($ip, "No cookie after $requestCount requests");
                $this->blockUserHash('No cookie bot');
                $this->sendBlockResponse();
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // ОБНОВЛЕНО v2.5: Slow Bot Detection - теперь БЛОКИРУЕТ сразу!
        // Раньше только включал extended tracking, теперь блокирует
        // ═══════════════════════════════════════════════════════════════════
        $trackingData = $this->getUserTrackingData($ip);
        if ($trackingData && $this->isPotentialSlowBot($trackingData)) {
            $instantBlock = $this->rateLimitSettings['slow_bot_instant_block'] ?? true;
            
            if ($instantBlock) {
                // v2.5: Жёсткий режим - блокируем сразу
                $requestCount = $trackingData['requests'] ?? 0;
                error_log("SLOW BOT BLOCKED: $ip | Requests: $requestCount | Pattern detected");
                $this->applyProgressiveBlock($ip, 'Slow bot pattern detected');
                $this->blockUserHash('Slow bot');
                $this->sendBlockResponse();
            } else {
                // Мягкий режим - только extended tracking (как раньше)
                if (!$hasExtendedTracking) {
                    // $this->enableExtendedTracking($ip, 'Potential slow bot pattern');
                }
            }
        }
        
        if (!isset($_COOKIE[$this->cookieName])) {
            $this->setVisitorCookie();
            $this->initTracking($ip);
        }
    }
    
    /**
     * ═══════════════════════════════════════════════════════════════════════
     * НОВЫЙ МЕТОД v2.4: Отправка 429 ответа с информацией о violations
     * 
     * Показывает красивую страницу 429 с предупреждением о блокировке
     * ═══════════════════════════════════════════════════════════════════════
     */
    private function send429Response($ip, $violations, $type, $details) {
        if (!headers_sent()) {
            // ═══════════════════════════════════════════════════════════════
            // КРИТИЧНО ДЛЯ SEO: Запрет индексации страницы 429
            // Google/Yandex НЕ ДОЛЖНЫ индексировать эту страницу!
            // ═══════════════════════════════════════════════════════════════
            header('X-Robots-Tag: noindex, nofollow');
            http_response_code(429);
            header('Content-Type: text/html; charset=utf-8');
            header('Retry-After: 60');
            header('X-RateLimit-Limit: ' . $this->rateLimitSettings['max_requests_per_minute']);
            header('X-RateLimit-Remaining: 0');
            header('X-Violations-RateLimit: ' . $violations['rate_limit']);
            header('X-Violations-Burst: ' . $violations['burst']);
            header('X-Violations-Total: ' . $violations['total']);
            header('X-Block-Threshold: ' . $this->rateLimitSettings['combined_api_block_threshold']);
        }
        
        $remaining = $this->rateLimitSettings['combined_api_block_threshold'] - $violations['total'];
        $remaining = max(0, $remaining);
        $progressPercent = min(100, ($violations['total'] / $this->rateLimitSettings['combined_api_block_threshold']) * 100);
        
        $html = '<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- ============================================================ -->
    <!-- КРИТИЧНО ДЛЯ SEO: Запрет индексации страницы 429           -->
    <!-- Google/Yandex НЕ ДОЛЖНЫ индексировать защитные страницы!   -->
    <!-- ============================================================ -->
    <meta name="robots" content="noindex, nofollow">
    <meta name="googlebot" content="noindex, nofollow">
    <meta name="yandex" content="noindex, nofollow">
    <!-- ============================================================ -->
    <title>429 - Too Many Requests</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .icon { font-size: 64px; margin-bottom: 20px; }
        h1 { color: #ff6b6b; margin: 0 0 10px 0; font-size: 28px; }
        .subtitle { color: #aaa; margin-bottom: 30px; }
        .warning-box {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        .warning-title { color: #ff6b6b; font-weight: bold; margin-bottom: 10px; }
        .stats { display: flex; justify-content: space-around; margin: 20px 0; flex-wrap: wrap; }
        .stat { text-align: center; padding: 10px; }
        .stat-value { font-size: 24px; font-weight: bold; color: #ff6b6b; }
        .stat-label { font-size: 12px; color: #888; }
        .progress-bar {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #ff6b6b);
            transition: width 0.3s;
        }
        .countdown { font-size: 14px; color: #888; margin-top: 20px; }
        .timer { font-size: 32px; font-weight: bold; color: #4ecdc4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">⚠️</div>
        <h1>Слишком много запросов</h1>
        <p class="subtitle">Вы превысили лимит запросов</p>
        
        <div class="warning-box">
            <div class="warning-title">⚡ Предупреждение</div>
            <p>При продолжении превышения лимитов ваш IP будет заблокирован.</p>
            <p><strong>Осталось до блокировки: ' . $remaining . ' нарушений</strong></p>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value">' . $violations['rate_limit'] . '</div>
                <div class="stat-label">Rate Limit</div>
            </div>
            <div class="stat">
                <div class="stat-value">' . $violations['burst'] . '</div>
                <div class="stat-label">Burst</div>
            </div>
            <div class="stat">
                <div class="stat-value">' . $violations['total'] . '</div>
                <div class="stat-label">Всего</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" style="width: ' . $progressPercent . '%"></div>
        </div>
        
        <div class="countdown">
            Повторите попытку через:
            <div class="timer" id="timer">60</div>
        </div>
    </div>
    
    <script>
        let seconds = 60;
        const timer = document.getElementById("timer");
        const interval = setInterval(() => {
            seconds--;
            timer.textContent = seconds;
            if (seconds <= 0) {
                clearInterval(interval);
                location.reload();
            }
        }, 1000);
    </script>
</body>
</html>';
        
        die($html);
    }
    
    /**
     * ОПТИМИЗИРОВАННЫЙ Global Rate Limit v2.3
     * Защита от DDoS - срабатывает при экстремальной нагрузке (>100 req/sec)
     * 
     * БЫЛО: 1 ключ на каждую секунду для каждого IP = тысячи ключей
     * СТАЛО: 1 ключ на IP со скользящим окном = минимум ключей
     */
    private function checkGlobalRateLimit($ip) {
        try {
            $currentSecond = time();
            
            // Один ключ на IP вместо ключа на каждую секунду!
            $key = $this->globalPrefix . 'grl:' . hash('md5', $ip);
            
            // Получаем текущие данные
            $data = $this->redis->get($key);
            
            $requests = 0;
            
            // Если данные есть и секунда та же - берём счётчик
            if ($data && is_array($data) && isset($data['second']) && (int)$data['second'] === $currentSecond) {
                $requests = (int)($data['requests'] ?? 0);
            }
            
            $requests++;
            
            // Сохраняем данные
            $this->redis->setex($key, 5, [
                'requests' => $requests,
                'second' => $currentSecond
            ]);
            
            // Порог: 100 запросов в секунду = явный DDoS
            if ($requests > 100) {
                return ['allowed' => false, 'requests' => $requests];
            }
            
            return ['allowed' => true, 'requests' => $requests];
        } catch (Exception $e) {
            return ['allowed' => true, 'requests' => 0];
        }
    }
    
    /**
     * НОВЫЙ МЕТОД: Проверка whitelist верифицированных поисковиков
     */
    private function isWhitelistedSearchEngine($ip) {
        try {
            $whitelistKey = $this->rdnsPrefix . 'whitelist:' . hash('md5', $ip);
            return $this->redis->exists($whitelistKey);
        } catch (Exception $e) {
            return false;
        }
    }
    
    /**
     * НОВЫЙ МЕТОД: Добавление в whitelist после rDNS верификации
     */
    private function addToSearchEngineWhitelist($ip, $userAgent) {
        try {
            $whitelistKey = $this->rdnsPrefix . 'whitelist:' . hash('md5', $ip);
            $data = [
                'ip' => $ip,
                'user_agent' => $userAgent,
                'verified_at' => time()
            ];
            // Кешируем на 24 часа - поисковики обычно используют стабильные IP
            $this->redis->setex($whitelistKey, 86400, $data);
        } catch (Exception $e) {
            error_log("Error adding to search engine whitelist: " . $e->getMessage());
        }
    }
    
    /**
     * ОПТИМИЗИРОВАННАЯ защита от переполнения Redis (БЕЗ торможения)
     */
    private function manageTrackedIPs() {
        try {
            // ШАГ 1: Быстрая проверка - нужна ли очистка вообще
            // Используем кешированный счетчик (обновляется редко)
            $countCacheKey = $this->globalPrefix . 'tracked_count_cache';
            $cachedCount = $this->redis->get($countCacheKey);
            
            // Если кеш пустой или устарел (обновляем раз в минуту)
            if ($cachedCount === false) {
                $approxCount = $this->getApproximateTrackedCount();
                $this->redis->setex($countCacheKey, 60, $approxCount);
                $cachedCount = $approxCount;
            }
            
            // Если далеко от лимита - выходим сразу (быстро!)
            if ($cachedCount < $this->globalProtectionSettings['cleanup_threshold']) {
                return 0;
            }
            
            // ШАГ 2: Очистка нужна - используем SCAN (не блокирует Redis)
            $cleaned = 0;
            $maxCleanupTime = $this->globalProtectionSettings['max_cleanup_time_ms'] / 1000; // в секунды
            $startTime = microtime(true);
            $batchSize = $this->globalProtectionSettings['cleanup_batch_size'];
            
            // SCAN итератор (безопасный для production)
            $iterator = null;
            // ВАЖНО: OPT_PREFIX НЕ применяется к паттернам SCAN - указываем полный путь
            $pattern = $this->redisPrefix . $this->trackingPrefix . 'ip:*';
            
            do {
                // SCAN возвращает порциями, не блокируя Redis
                $keys = $this->redis->scan($iterator, $pattern, 50); // 50 ключей за раз
                
                if ($keys === false) break;
                
                foreach ($keys as $key) {
                    // Лимит времени - прерываем если долго
                    if ((microtime(true) - $startTime) > $maxCleanupTime) {
                        break 2;
                    }
                    
                    // Лимит количества
                    if ($cleaned >= $batchSize) {
                        break 2;
                    }
                    
                    // SCAN возвращает полный путь, убираем redisPrefix для команд Redis
                    $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                    
                    // БЫСТРАЯ проверка: смотрим только TTL (без GET данных)
                    $ttl = $this->redis->ttl($keyWithoutPrefix);
                    
                    // Стратегия 1: Удаляем ключи с TTL < 10 минут (скоро истекут)
                    if ($ttl > 0 && $ttl < 600) {
                        $this->redis->del($keyWithoutPrefix);
                        $this->decrementTrackedCounter();
                        $cleaned++;
                        continue;
                    }
                    
                    // Стратегия 2: Для старых ключей проверяем активность
                    if ($ttl === -1 || $ttl > 3600) {
                        $data = $this->redis->get($keyWithoutPrefix);
                        
                        if ($data && isset($data['first_seen'], $data['requests'])) {
                            $age = time() - $data['first_seen'];
                            
                            // Удаляем старые (>2 часа) с низкой активностью (<10 запросов)
                            if ($age > 7200 && $data['requests'] < 10) {
                                $this->redis->del($keyWithoutPrefix);
                                $this->decrementTrackedCounter();
                                $cleaned++;
                            }
                            // Удаляем очень старые (>6 часов) независимо от активности
                            elseif ($age > 21600) {
                                $this->redis->del($keyWithoutPrefix);
                                $this->decrementTrackedCounter();
                                $cleaned++;
                            }
                        }
                    }
                }
                
            } while ($iterator !== 0 && $iterator !== null);
            
            // ШАГ 3: Обновляем счетчик после очистки
            if ($cleaned > 0) {
                $newCount = max(0, $cachedCount - $cleaned);
                $this->redis->setex($countCacheKey, 60, $newCount);
                error_log("Redis cleanup: removed $cleaned tracked IPs (approx " . 
                         round((microtime(true) - $startTime) * 1000, 2) . "ms)");
            }
            
            return $cleaned;
            
        } catch (Exception $e) {
            error_log("Error in manageTrackedIPs: " . $e->getMessage());
            return 0;
        }
    }
    
    /**
     * Быстрая примерная оценка количества tracked IP
     */
    private function getApproximateTrackedCount() {
        try {
            // Вариант 1: Используем отдельный счетчик (инкремент/декремент)
            $counterKey = $this->globalPrefix . 'tracked_counter';
            $count = $this->redis->get($counterKey);
            
            if ($count !== false) {
                return (int)$count;
            }
            
            // Вариант 2: Точный подсчет (только если счетчик сброшен)
            $iterator = null;
            $counted = 0;
            $maxToCount = 1000; // Считаем максимум 1000 для оценки
            
            while ($counted < $maxToCount) {
                // ВАЖНО: OPT_PREFIX НЕ применяется к паттернам SCAN - указываем полный путь
                $keys = $this->redis->scan($iterator, $this->redisPrefix . $this->trackingPrefix . 'ip:*', 100);
                if ($keys === false) break;
                
                $counted += count($keys);
                
                if ($iterator === 0 || $iterator === null) break;
            }
            
            // Сохраняем в счетчик
            $this->redis->setex($counterKey, 300, $counted); // 5 минут кеш
            
            return $counted;
            
        } catch (Exception $e) {
            error_log("Error getting tracked count: " . $e->getMessage());
            return 0;
        }
    }
    
    /**
     * Инкремент счетчика tracked IP (вызывать при добавлении)
     */
    private function incrementTrackedCounter() {
        try {
            $counterKey = $this->globalPrefix . 'tracked_counter';
            $this->redis->incr($counterKey);
            $this->redis->expire($counterKey, 3600); // 1 час
        } catch (Exception $e) {
            // Не критично, просто счетчик не обновится
        }
    }
    
    /**
     * Декремент счетчика tracked IP (вызывать при удалении)
     */
    private function decrementTrackedCounter() {
        try {
            $counterKey = $this->globalPrefix . 'tracked_counter';
            $this->redis->decr($counterKey);
        } catch (Exception $e) {
            // Не критично
        }
    }
    
    private function shouldAnalyzeIP($ip) {
        try {
            $trackingKey = $this->trackingPrefix . 'ip:' . hash('md5', $ip);
            $data = $this->redis->get($trackingKey);
            
            if ($data) {
                $requests = $data['requests'] ?? 0;
                $timeSpent = time() - ($data['first_seen'] ?? time());
                $suspicious_ua = $this->isSuspiciousUserAgent($_SERVER['HTTP_USER_AGENT'] ?? '');
                
                if ($suspicious_ua) {
                    return true;
                }
                
                if ($timeSpent > 1800 && $requests >= 5) {
                    return true;
                }
                
                if ($requests > 5) {
                    return true;
                }
                
                if ($timeSpent > 0 && $requests >= $this->slowBotSettings['min_requests_for_analysis']) {
                    $requestsPerMinute = ($requests * 60) / $timeSpent;
                    if ($requestsPerMinute > 40) {
                        return true;
                    }
                }
                
                if (isset($data['request_times']) && count($data['request_times']) >= 7) {
                    $recentTimes = array_slice($data['request_times'], -7);
                    $timeSpan = end($recentTimes) - reset($recentTimes);
                    if ($timeSpan <= 20) {
                        return true;
                    }
                }
            }
            
            return false;
        } catch (Exception $e) {
            error_log("Error in shouldAnalyzeIP: " . $e->getMessage());
            return false;
        }
    }
    
    private function isSuspiciousUserAgent($userAgent) {
        $suspiciousPatterns = [
            'curl', 'wget', 'python', 'java/', 'go-http', 'node-fetch', 
            'libwww', 'scrapy', 'requests', 'urllib', 'httpie', 'bot', 'spider',
            'crawler', 'scraper', 'postman', 'insomnia'
        ];
        
        $userAgent = strtolower($userAgent);
        
        foreach ($suspiciousPatterns as $pattern) {
            if (strpos($userAgent, $pattern) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Проверка подозрительных HTTP заголовков
     * Реальные браузеры отправляют много заголовков, боты - мало
     * 
     * @return array ['suspicious' => bool, 'score' => int, 'missing' => array]
     */
    private function checkSuspiciousHeaders() {
        $score = 0;
        $missing = [];
        
        // ═══════════════════════════════════════════════════════════════════════
        // ИСКЛЮЧЕНИЕ ДЛЯ AJAX/FETCH ЗАПРОСОВ
        // ═══════════════════════════════════════════════════════════════════════
        // AJAX запросы (поиск DLE, динамическая загрузка и т.д.) имеют другие
        // заголовки чем обычные страницы - это НОРМАЛЬНО, не блокируем их
        // ═══════════════════════════════════════════════════════════════════════
        
        // Метод 1: XMLHttpRequest (jQuery, старый JS)
        $isXHR = !empty($_SERVER['HTTP_X_REQUESTED_WITH']) && 
                 strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) === 'xmlhttprequest';
        
        // Метод 2: Sec-Fetch-Mode (современные браузеры)
        // cors, same-origin, no-cors = fetch/AJAX запросы
        // navigate = обычная навигация (загрузка страницы)
        $secFetchMode = $_SERVER['HTTP_SEC_FETCH_MODE'] ?? '';
        $isModernAjax = in_array($secFetchMode, ['cors', 'same-origin', 'no-cors']);
        
        // Метод 3: Sec-Fetch-Dest (тип запрашиваемого ресурса)
        // empty = fetch/AJAX, document = страница
        $secFetchDest = $_SERVER['HTTP_SEC_FETCH_DEST'] ?? '';
        $isFetchRequest = ($secFetchDest === 'empty');
        
        // Метод 4: Accept заголовок указывает на JSON/XML (API запрос)
        $accept = $_SERVER['HTTP_ACCEPT'] ?? '';
        $isApiRequest = (stripos($accept, 'application/json') !== false || 
                        stripos($accept, 'application/xml') !== false ||
                        stripos($accept, 'text/javascript') !== false);
        
        // Если это AJAX/Fetch запрос от браузера - применяем МЯГКИЕ проверки
        if ($isXHR || $isModernAjax || $isFetchRequest || $isApiRequest) {
            // Для AJAX проверяем только критичные вещи
            $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? '';
            
            // Нет User-Agent вообще - подозрительно даже для AJAX
            if (empty($userAgent)) {
                $score += 3;
                $missing[] = 'NO_USER_AGENT_AJAX';
            }
            
            // Нет Accept-Language - немного подозрительно
            if (empty($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
                $score += 1;
                $missing[] = 'NO_LANG_AJAX';
            }
            
            // Для AJAX порог подозрительности выше
            return [
                'suspicious' => $score >= 4,  // Только при score >= 4 для AJAX
                'score' => $score,
                'missing' => $missing,
                'is_ajax' => true
            ];
        }
        
        // ═══════════════════════════════════════════════════════════════════════
        // ПОЛНАЯ ПРОВЕРКА ДЛЯ ОБЫЧНЫХ ЗАПРОСОВ (загрузка страниц)
        // ═══════════════════════════════════════════════════════════════════════
        
        // Заголовки, которые ДОЛЖНЫ быть у реального браузера
        $requiredHeaders = [
            'HTTP_ACCEPT_LANGUAGE' => 3,     // Все браузеры отправляют язык
            'HTTP_ACCEPT_ENCODING' => 2,     // gzip, deflate, br
            'HTTP_ACCEPT' => 1,              // text/html,application/xhtml+xml,...
        ];
        
        foreach ($requiredHeaders as $header => $penalty) {
            if (empty($_SERVER[$header])) {
                $score += $penalty;
                $missing[] = $header;
            }
        }
        
        // Проверка Accept - боты часто отправляют только "*/*"
        if ($accept === '*/*' || strlen($accept) < 10) {
            $score += 2;
            $missing[] = 'BAD_ACCEPT';
        }
        
        // Проверка Accept-Language - должен быть валидный язык
        $acceptLang = $_SERVER['HTTP_ACCEPT_LANGUAGE'] ?? '';
        if (!empty($acceptLang)) {
            // Должен содержать код языка типа en, ru, uk и т.д.
            if (!preg_match('/^[a-z]{2}(-[A-Z]{2})?(,|;|$)/i', $acceptLang)) {
                $score += 2;
                $missing[] = 'INVALID_LANG';
            }
        }
        
        // Проверка Accept-Encoding - современные браузеры поддерживают gzip
        $acceptEnc = $_SERVER['HTTP_ACCEPT_ENCODING'] ?? '';
        if (!empty($acceptEnc) && stripos($acceptEnc, 'gzip') === false) {
            $score += 1;
        }
        
        // Проверка Connection заголовка
        $connection = $_SERVER['HTTP_CONNECTION'] ?? '';
        if (empty($connection)) {
            $score += 1;
            $missing[] = 'NO_CONNECTION';
        }
        
        // Проверка User-Agent
        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? '';
        if (empty($userAgent)) {
            $score += 4;  // Нет User-Agent = почти точно бот
            $missing[] = 'NO_USER_AGENT';
        } elseif (strlen($userAgent) < 20) {
            $score += 2;  // Слишком короткий UA
            $missing[] = 'SHORT_USER_AGENT';
        }
        
        // Sec-Fetch-* заголовки (современные браузеры Chrome/Firefox/Edge)
        // Их отсутствие не критично для старых браузеров, но добавляет к подозрению
        $secFetchSite = $_SERVER['HTTP_SEC_FETCH_SITE'] ?? '';
        
        // Если UA говорит что это Chrome 80+ но нет Sec-Fetch = бот
        if (preg_match('/Chrome\/(\d+)/', $userAgent, $matches)) {
            $chromeVersion = (int)$matches[1];
            if ($chromeVersion >= 80 && empty($secFetchMode)) {
                $score += 3;
                $missing[] = 'NO_SEC_FETCH_CHROME';
            }
        }
        
        // Upgrade-Insecure-Requests (большинство браузеров отправляют при загрузке страниц)
        $upgradeInsecure = $_SERVER['HTTP_UPGRADE_INSECURE_REQUESTS'] ?? '';
        if (empty($upgradeInsecure) && !empty($userAgent) && 
            (stripos($userAgent, 'chrome') !== false || stripos($userAgent, 'firefox') !== false)) {
            $score += 1;
        }
        
        return [
            'suspicious' => $score >= 4,
            'score' => $score,
            'missing' => $missing,
            'is_ajax' => false
        ];
    }
    
    /**
     * Анализ типов запрашиваемых страниц
     * Боты обычно запрашивают только HTML, не загружая ресурсы
     */
    // analyzeRequestTypes() removed in optimization (saved 35 lines)
    
    private function isLegitimateBot($userAgent) {
        $legitimateBots = [
            'uptimerobot', 'pingdom', 'statuscake', 'site24x7',
            'cloudflare', 'fastly', 'keycdn', 'meta-externalagent',
            'oai-searchbot', 'chatgpt-user', 'gptbot', 'claude-user', 'claudeBot', 'telegram', 'hosttracker', 'perplexity-user'
        ];
        
        $userAgent = strtolower($userAgent);
        
        foreach ($legitimateBots as $bot) {
            if (strpos($userAgent, $bot) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    private function logBotVisit($ip, $userAgent, $type) {
        try {
            $logEntry = [
                'timestamp' => date('Y-m-d H:i:s'),
                'ip' => $ip,
                'user_agent' => $userAgent,
                'type' => $type,
                'uri' => $_SERVER['REQUEST_URI'] ?? ''
            ];
            
            $logKey = 'logs:legitimate_bots:' . date('Y-m-d');
            $this->redis->lpush($logKey, $logEntry);
            $this->redis->expire($logKey, $this->ttlSettings['logs']);
            $this->redis->ltrim($logKey, 0, 999);
        } catch (Exception $e) {
            error_log("Error logging bot visit: " . $e->getMessage());
        }
    }
    
    private function isVerifiedSearchEngine($ip, $userAgent) {
        $detectedEngine = null;
        $engineConfig = null;
        foreach ($this->allowedSearchEngines as $engine => $config) {
            foreach ($config['user_agent_patterns'] as $pattern) {
                if (stripos($userAgent, $pattern) !== false) {
                    $detectedEngine = $engine;
                    $engineConfig = $config;
                    break 2;
                }
            }
        }
        
        if (!$detectedEngine || !$engineConfig) {
            return false;
        }
        
        return $this->verifySearchEngineByRDNS($ip, $engineConfig);
    }
    
    private function verifySearchEngineByRDNS($ip, $engineConfig) {
        // Поддержка старого формата (массив паттернов) и нового (полный конфиг)
        if (isset($engineConfig['rdns_patterns'])) {
            $allowedPatterns = $engineConfig['rdns_patterns'];
            $skipForwardVerification = $engineConfig['skip_forward_verification'] ?? false;
        } else {
            // Старый формат - просто массив паттернов
            $allowedPatterns = $engineConfig;
            $skipForwardVerification = false;
        }
        
        try {
            $normalizedIP = $this->normalizeIP($ip);
            $cacheKey = $this->rdnsPrefix . 'cache:' . hash('md5', $normalizedIP);
            
            // СНАЧАЛА проверяем кеш (до rate limit проверки!)
            $cached = $this->redis->get($cacheKey);
            if ($cached !== false) {
                return $cached['verified'];
            }
            
            // Проверяем rate limit для rDNS
            $rdnsLimitCheck = $this->checkRDNSRateLimit();
            if (!$rdnsLimitCheck['allowed']) {
                // При превышении лимита и отсутствии кеша
                if ($this->rdnsLimitSettings['rdns_on_limit_action'] === 'block') {
                    error_log("rDNS rate limit exceeded, blocking IP: $normalizedIP");
                    return false;
                }
                
                // НОВОЕ: Доверяем UA поисковика при превышении лимита
                if (!empty($this->rdnsLimitSettings['trust_search_engine_ua_on_limit'])) {
                    error_log("rDNS rate limit exceeded, trusting search engine UA for: $normalizedIP");
                    // Кешируем как "условно верифицированный" с коротким TTL
                    $this->redis->setex($cacheKey, 300, [
                        'ip' => $normalizedIP,
                        'hostname' => 'trusted_by_ua',
                        'verified' => true,
                        'timestamp' => time(),
                        'trusted_reason' => 'rdns_limit_exceeded'
                    ]);
                    return true;
                }
                
                // 'skip' - пропускаем проверку
                error_log("rDNS rate limit exceeded, skipping verification for: $normalizedIP");
                return false;
            }
            
            $verified = false;
            $hostname = '';
            $error = '';
            
            try {
                $hostname = $this->getHostnameWithTimeout($normalizedIP, 2);
                
                if ($hostname && $hostname !== $normalizedIP) {
                    $hostnameMatches = false;
                    foreach ($allowedPatterns as $pattern) {
                        if ($this->matchesDomainPattern($hostname, $pattern)) {
                            $hostnameMatches = true;
                            break;
                        }
                    }
                    
                    if ($hostnameMatches) {
                        // Если skip_forward_verification - доверяем только rDNS
                        if ($skipForwardVerification) {
                            $verified = true;
                            error_log("rDNS verified (forward skip): $normalizedIP -> $hostname");
                        } else {
                            // Стандартная проверка: forward lookup
                            $forwardIPs = $this->getIPsWithTimeout($hostname, 2);
                            
                            if ($forwardIPs && $this->ipInArray($normalizedIP, $forwardIPs)) {
                                $verified = true;
                            }
                        }
                    }
                }
                
            } catch (Exception $e) {
                $error = $e->getMessage();
            }
            
            $cacheData = [
                'ip' => $normalizedIP,
                'hostname' => $hostname,
                'verified' => $verified,
                'timestamp' => time(),
                'error' => $error,
                'skip_forward' => $skipForwardVerification
            ];
            
            // Разный TTL для положительных и отрицательных результатов
            $cacheTTL = $verified ? 
                $this->rdnsLimitSettings['rdns_cache_ttl'] : 
                $this->rdnsLimitSettings['rdns_negative_cache_ttl'];
            
            $this->redis->setex($cacheKey, $cacheTTL, $cacheData);
            
            return $verified;
        } catch (Exception $e) {
            error_log("Error in rDNS verification: " . $e->getMessage());
            return false;
        }
    }
    
    private function getHostnameWithTimeout($ip, $timeoutSec = 2) {
        $originalTimeout = ini_get('default_socket_timeout');
        ini_set('default_socket_timeout', $timeoutSec);
        
        try {
            $hostname = @gethostbyaddr($ip);
            ini_set('default_socket_timeout', $originalTimeout);
            return ($hostname !== $ip) ? $hostname : false;
        } catch (Exception $e) {
            ini_set('default_socket_timeout', $originalTimeout);
            return false;
        }
    }
    
    private function getIPsWithTimeout($hostname, $timeoutSec = 2) {
        $originalTimeout = ini_get('default_socket_timeout');
        ini_set('default_socket_timeout', $timeoutSec);
        
        $allIPs = [];
        
        try {
            $ipv4List = @gethostbynamel($hostname);
            if ($ipv4List) {
                $allIPs = array_merge($allIPs, $ipv4List);
            }
            
            if (function_exists('dns_get_record')) {
                $records = @dns_get_record($hostname, DNS_AAAA);
                if ($records) {
                    foreach ($records as $record) {
                        if (isset($record['ipv6'])) {
                            $allIPs[] = $this->normalizeIPv6($record['ipv6']);
                        }
                    }
                }
            }
            
            ini_set('default_socket_timeout', $originalTimeout);
            return array_unique($allIPs);
            
        } catch (Exception $e) {
            ini_set('default_socket_timeout', $originalTimeout);
            return [];
        }
    }
    
    private function matchesDomainPattern($hostname, $pattern) {
        $hostname = strtolower(trim($hostname));
        $pattern = strtolower(trim($pattern));
        
        if ($hostname === $pattern) {
            return true;
        }
        
        if (strpos($pattern, '.') === 0) {
            return substr($hostname, -strlen($pattern)) === $pattern;
        }
        
        $fullPattern = '.' . $pattern;
        return substr($hostname, -strlen($fullPattern)) === $fullPattern;
    }
    
    private function ipInArray($needle, $haystack) {
        $normalizedNeedle = $this->normalizeIP($needle);
        
        foreach ($haystack as $ip) {
            if ($this->normalizeIP($ip) === $normalizedNeedle) {
                return true;
            }
        }
        
        return false;
    }
    
    private function logSearchEngineVisit($ip, $userAgent) {
        try {
            $logEntry = [
                'timestamp' => date('Y-m-d H:i:s'),
                'ip' => $ip,
                'user_agent' => $userAgent,
                'uri' => $_SERVER['REQUEST_URI'] ?? '',
                'hostname' => @gethostbyaddr($ip)
            ];
            
            $logKey = 'logs:search_engines:' . date('Y-m-d');
            $this->redis->lpush($logKey, $logEntry);
            $this->redis->expire($logKey, $this->ttlSettings['logs']);
            $this->redis->ltrim($logKey, 0, 999);
        } catch (Exception $e) {
            error_log("Error logging search engine visit: " . $e->getMessage());
        }
    }
    
    private function getRealIP() {
        $ipHeaders = [
            'HTTP_CF_CONNECTING_IP',
            'HTTP_X_REAL_IP',
            'HTTP_X_FORWARDED_FOR',
            'HTTP_X_FORWARDED',
            'HTTP_X_CLUSTER_CLIENT_IP',
            'HTTP_FORWARDED_FOR',
            'HTTP_FORWARDED',
            'REMOTE_ADDR'
        ];
        
        foreach ($ipHeaders as $header) {
            if (!empty($_SERVER[$header])) {
                $ips = explode(',', $_SERVER[$header]);
                $ip = trim($ips[0]);
                
                if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
                    $ip = $this->normalizeIPv6($ip);
                }
                
                if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
                    if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {
                        return $ip;
                    }
                } elseif (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
                    if (!$this->isPrivateIPv6($ip)) {
                        return $ip;
                    }
                }
            }
        }
        
        $remoteAddr = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        if ($remoteAddr !== 'unknown' && filter_var($remoteAddr, FILTER_VALIDATE_IP)) {
            if (filter_var($remoteAddr, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
                return $this->normalizeIPv6($remoteAddr);
            }
            return $remoteAddr;
        }
        
        return 'unknown';
    }
    
    private function isPrivateIPv6($ip) {
        $privateRanges = [
            '::1',
            'fe80::/10',
            'fc00::/7',
            'ff00::/8',
        ];
        
        foreach ($privateRanges as $range) {
            if ($this->ipInRange($ip, $range)) {
                return true;
            }
        }
        
        return false;
    }
    
    private function ipInRange($ip, $range) {
        if (strpos($range, '/') === false) {
            return $ip === $range;
        }
        
        list($subnet, $prefix) = explode('/', $range);
        
        $ipBin = @inet_pton($ip);
        $subnetBin = @inet_pton($subnet);
        
        if ($ipBin === false || $subnetBin === false) {
            return false;
        }
        
        $ipFamily = filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? AF_INET6 : AF_INET;
        $subnetFamily = filter_var($subnet, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) ? AF_INET6 : AF_INET;
        
        if ($ipFamily !== $subnetFamily) {
            return false;
        }
        
        $maxBits = $ipFamily === AF_INET6 ? 128 : 32;
        $prefix = max(0, min($maxBits, (int)$prefix));
        
        $bytesToCheck = intval($prefix / 8);
        $bitsInLastByte = $prefix % 8;
        
        for ($i = 0; $i < $bytesToCheck; $i++) {
            if ($ipBin[$i] !== $subnetBin[$i]) {
                return false;
            }
        }
        
        if ($bitsInLastByte > 0) {
            $mask = 0xFF << (8 - $bitsInLastByte);
            if ((ord($ipBin[$bytesToCheck]) & $mask) !== (ord($subnetBin[$bytesToCheck]) & $mask)) {
                return false;
            }
        }
        
        return true;
    }
    
    private function isStaticFile() {
        $uri = $_SERVER['REQUEST_URI'] ?? '';
        $staticExtensions = [
            '.css', '.js', '.jpg', '.jpeg', '.png', '.gif', '.ico', '.svg', 
            '.woff', '.woff2', '.ttf', '.eot', '.otf', '.webp', '.avif',
            '.pdf', '.zip', '.mp4', '.webm', '.mp3', '.wav', '.txt'
        ];
        
        foreach ($staticExtensions as $ext) {
            if (substr($uri, -strlen($ext)) === $ext) {
                return true;
            }
        }
        return false;
    }
    
    private function hasValidCookie() {
        if (!isset($_COOKIE[$this->cookieName])) {
            return false;
        }
        
        $data = json_decode($_COOKIE[$this->cookieName], true);
        if (!$data || !isset($data['hash'], $data['time'])) {
            return false;
        }
        
        if (time() - $data['time'] > $this->cookieLifetime) {
            return false;
        }
        
        $expected = hash('sha256', $data['time'] . ($_SERVER['HTTP_USER_AGENT'] ?? '') . $this->secretKey);
        return hash_equals($expected, $data['hash']);
    }
    
    private function setVisitorCookie() {
        try {
            $time = time();
            $hash = hash('sha256', $time . ($_SERVER['HTTP_USER_AGENT'] ?? '') . $this->secretKey);
            $cookieData = json_encode(['time' => $time, 'hash' => $hash]);
            
            $secure = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';
            setcookie($this->cookieName, $cookieData, time() + $this->cookieLifetime, '/', '', $secure, true);
            $_COOKIE[$this->cookieName] = $cookieData;
        } catch (Exception $e) {
            error_log("Error setting visitor cookie: " . $e->getMessage());
        }
    }
    
    private function initTracking($ip) {
        try {
            $trackingKey = $this->trackingPrefix . 'ip:' . hash('md5', $ip);
            $existing = $this->redis->get($trackingKey);
            
            if ($existing) {
                $existing['requests']++;
                $existing['pages'][] = parse_url($_SERVER['REQUEST_URI'] ?? '', PHP_URL_PATH);
                $existing['user_agents'][] = $_SERVER['HTTP_USER_AGENT'] ?? '';
                $existing['user_agents'] = array_unique($existing['user_agents']);
                $existing['request_times'][] = time();
                $existing['real_ip'] = $ip;
                
                if (count($existing['request_times']) > 25) {
                    $existing['request_times'] = array_slice($existing['request_times'], -25);
                }
                if (count($existing['pages']) > 40) {
                    $existing['pages'] = array_slice($existing['pages'], -40);
                }
                if (count($existing['user_agents']) > 5) {
                    $existing['user_agents'] = array_slice($existing['user_agents'], -5);
                }
                
                $this->redis->setex($trackingKey, $this->ttlSettings['tracking_ip'], $existing);
            } else {
                // НОВАЯ запись - инкрементируем счетчик
                $data = [
                    'first_seen' => time(),
                    'requests' => 1,
                    'pages' => [parse_url($_SERVER['REQUEST_URI'] ?? '', PHP_URL_PATH)],
                    'user_agents' => [$_SERVER['HTTP_USER_AGENT'] ?? ''],
                    'headers' => $this->collectHeaders(),
                    'session_id' => 'no_session',
                    'request_times' => [time()],
                    'real_ip' => $ip
                ];
                
                $this->redis->setex($trackingKey, $this->ttlSettings['tracking_ip'], $data);
                
                // Увеличиваем счетчик tracked IP
                $this->incrementTrackedCounter();
            }
        } catch (Exception $e) {
            error_log("Error in initTracking: " . $e->getMessage());
        }
    }
    
    private function collectHeaders() {
        $headers = [];
        $importantHeaders = [
            'HTTP_USER_AGENT', 'HTTP_ACCEPT', 'HTTP_ACCEPT_LANGUAGE', 
            'HTTP_ACCEPT_ENCODING', 'HTTP_REFERER', 'HTTP_X_FORWARDED_FOR',
            'HTTP_CF_CONNECTING_IP', 'HTTP_X_REAL_IP', 'REMOTE_ADDR'
        ];
        
        foreach ($importantHeaders as $header) {
            if (isset($_SERVER[$header])) {
                $headers[$header] = $_SERVER[$header];
            }
        }
        return $headers;
    }
    
    private function blockCookieHash() {
        try {
            if (!isset($_COOKIE[$this->cookieName])) {
                return;
            }
            
            $data = json_decode($_COOKIE[$this->cookieName], true);
            if (!$data || !isset($data['hash'])) {
                return;
            }
            
            $blockKey = $this->cookiePrefix . 'blocked:' . hash('md5', $data['hash']);
            $blockData = [
                'cookie_hash' => $data['hash'],
                'blocked_at' => time(),
                'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? '',
                'uri' => $_SERVER['REQUEST_URI'] ?? '',
                'session_id' => 'no_session',
                'ip' => $this->getRealIP()
            ];
            
            $this->redis->setex($blockKey, $this->ttlSettings['cookie_blocked'], $blockData);
            
            error_log("Bot blocked [COOKIE]: " . substr($data['hash'], 0, 8) . " | IP: " . $this->getRealIP());
        } catch (Exception $e) {
            error_log("Error blocking cookie hash: " . $e->getMessage());
        }
    }
    
    private function isCookieBlocked() {
        try {
            if (!isset($_COOKIE[$this->cookieName])) {
                return false;
            }
            
            $data = json_decode($_COOKIE[$this->cookieName], true);
            if (!$data || !isset($data['hash'])) {
                return false;
            }
            
            $blockKey = $this->cookiePrefix . 'blocked:' . hash('md5', $data['hash']);
            return $this->redis->exists($blockKey);
        } catch (Exception $e) {
            error_log("Error checking cookie block: " . $e->getMessage());
            return false;
        }
    }
    
    // isMobileDevice() removed in optimization (saved 24 lines)
    
    private function analyzeRequest($ip) {
        try {
            $trackingKey = $this->trackingPrefix . 'ip:' . hash('md5', $ip);
            $data = $this->redis->get($trackingKey);
            
            if (!$data) {
                return false;
            }
            
            $score = 0;
            $currentUA = $_SERVER['HTTP_USER_AGENT'] ?? '';
            $isMobile = false /* isMobileDevice removed */;
            
            $blockThreshold = $isMobile ? 20 : 18;
            
            if ($this->isSuspiciousUserAgent($currentUA)) {
                $score += $isMobile ? 15 : 20;
            }
            
            $requests = $data['requests'] ?? 0;
            $timeSpent = time() - ($data['first_seen'] ?? time());
            
            if ($timeSpent > 0) {
                $requestsPerMinute = ($requests * 60) / $timeSpent;
                
                if ($isMobile) {
                    if ($requestsPerMinute > 180) $score += 12;
                    elseif ($requestsPerMinute > 120) $score += 8;
                    elseif ($requestsPerMinute > 80) $score += 4;
                } else {
                    if ($requestsPerMinute > 150) $score += 12;
                    elseif ($requestsPerMinute > 100) $score += 8;
                    elseif ($requestsPerMinute > 60) $score += 4;
                }
            }
            
            $cookieLimit = $isMobile ? 35 : 30;
            if ($requests > $cookieLimit && !isset($_COOKIE[$this->cookieName])) {
                $score += $isMobile ? 3 : 4;
            }
            
            $currentHeaders = $this->collectHeaders();
            
            if (!isset($currentHeaders['HTTP_ACCEPT']) || $currentHeaders['HTTP_ACCEPT'] === '*/*') {
                $score += $isMobile ? 1 : 2;
            }
            if (!isset($currentHeaders['HTTP_ACCEPT_LANGUAGE'])) {
                $score += $isMobile ? 1 : 2;
            }
            if (!isset($currentHeaders['HTTP_ACCEPT_ENCODING'])) {
                $score += $isMobile ? 1 : 2;
            }
            
            $uniquePages = array_unique($data['pages'] ?? []);
            $totalPages = count($data['pages'] ?? []);
            
            $pageLimit = $isMobile ? 50 : 40;
            if ($totalPages > $pageLimit && count($uniquePages) <= 2) {
                $score += $isMobile ? 2 : 3;
            }
            
            $uniqueUA = array_unique($data['user_agents'] ?? []);
            if (count($uniqueUA) > 5) {
                $score += 8;
            }
            
            if (isset($data['request_times']) && count($data['request_times']) >= 15) {
                $intervals = [];
                $lastFifteen = array_slice($data['request_times'], -15);
                
                for ($i = 1; $i < count($lastFifteen); $i++) {
                    $intervals[] = $lastFifteen[$i] - $lastFifteen[$i-1];
                }
                
                if (count($intervals) >= 12) {
                    $avgInterval = array_sum($intervals) / count($intervals);
                    $variance = 0;
                    foreach ($intervals as $interval) {
                        $variance += pow($interval - $avgInterval, 2);
                    }
                    $variance /= count($intervals);
                    
                    $varianceThreshold = $isMobile ? 1.0 : 1.5;
                    $intervalThreshold = $isMobile ? 3 : 5;
                    
                    if ($variance < $varianceThreshold && $avgInterval < $intervalThreshold) {
                        $score += $isMobile ? 3 : 5;
                    }
                }
            }
            
            if (isset($data['request_times']) && count($data['request_times']) >= 10) {
                $lastTen = array_slice($data['request_times'], -10);
                $timeDiff = end($lastTen) - reset($lastTen);
                
                if ($timeDiff <= 5) {
                    $score += $isMobile ? 3 : 5;
                }
                if ($timeDiff <= 2) {
                    $score += 6;
                }
            }
            
            return $score >= $blockThreshold;
        } catch (Exception $e) {
            error_log("Error in analyzeRequest: " . $e->getMessage());
            return false;
        }
    }
    
    private function isBlocked($ip) {
        try {
            $blockKey = $this->blockPrefix . 'ip:' . hash('md5', $ip);
            return $this->redis->exists($blockKey);
        } catch (Exception $e) {
            error_log("Error checking IP block: " . $e->getMessage());
            return false;
        }
    }
    
    private function blockIP($ip, $reason = 'Bot behavior detected') {
    try {
        $blockKey = $this->blockPrefix . 'ip:' . hash('md5', $ip);
        $apiCallKey = $this->blockPrefix . 'api_call:' . hash('md5', $ip);
        
        $isRepeatOffender = $this->redis->exists($blockKey);
        
        $blockData = [
            'ip' => $ip,
            'blocked_at' => time(),
            'blocked_reason' => $reason,
            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? '',
            'uri' => $_SERVER['REQUEST_URI'] ?? '',
            'session_id' => 'no_session',
            'repeat_offender' => $isRepeatOffender,
            'is_suspicious_ua' => $this->isSuspiciousUserAgent($_SERVER['HTTP_USER_AGENT'] ?? ''),
            'browser_info' => $this->getBrowserFingerprint($_SERVER['HTTP_USER_AGENT'] ?? ''),
            'api_blocked' => false  // Будет обновлено ниже
        ];
        
        $blockDuration = $isRepeatOffender ? $this->ttlSettings['ip_blocked_repeat'] : $this->ttlSettings['ip_blocked'];
        
        // Блокировка в Redis (локально)
        if ($this->apiSettings['block_on_redis']) {
            $this->redis->setex($blockKey, $blockDuration, $blockData);
        }
        
        // Блокировка через API (iptables)
        if ($this->apiSettings['block_on_api']) {
            $apiResult = $this->callBlockingAPI($ip, 'block');
            
            if ($apiResult['status'] === 'success' || $apiResult['status'] === 'already_blocked') {
				$this->redis->setex($apiCallKey, 60, time()); // Защита на 60 секунд
                $blockData['api_blocked'] = true;
                $blockData['api_blocked_at'] = time();
                $blockData['api_result'] = $apiResult['message'];
                
                // Обновляем данные в Redis с информацией об API блокировке
                if ($this->apiSettings['block_on_redis']) {
                    $this->redis->setex($blockKey, $blockDuration, $blockData);
                }
            } else {
                $blockData['api_blocked'] = false;
                $blockData['api_error'] = $apiResult['message'] ?? 'API call failed';
                
                if ($this->apiSettings['block_on_redis']) {
                    $this->redis->setex($blockKey, $blockDuration, $blockData);
                }
            }
        }
        
        $durHours = round($blockDuration / 3600);
        $apiStatus = $blockData['api_blocked'] ? 'API+Redis' : 'Redis only';
        error_log("Bot blocked [IP]: $ip | {$apiStatus} | " . ($isRepeatOffender ? "REPEAT | " : "") . "{$durHours}h | $reason");
        
    } catch (Exception $e) {
        error_log("Error blocking IP: " . $e->getMessage());
    }
}
    
	/**
     * Отправка запроса к API для блокировки/разблокировки IP
     * 
     * @param string $ip IP адрес для блокировки/разблокировки
     * @param string $action 'block' или 'unblock'
     * @return array Результат выполнения API запроса
     */
    private function callBlockingAPI($ip, $action = 'block') {
        if (!$this->apiSettings['enabled']) {
            return ['status' => 'disabled', 'message' => 'API integration disabled'];
        }
        
        if (!$this->apiSettings['block_on_api']) {
            return ['status' => 'skipped', 'message' => 'API blocking disabled in settings'];
        }
        
        $normalizedIP = $this->normalizeIP($ip);
        
        $url = $this->apiSettings['url'] . 
               '?action=' . urlencode($action) . 
               '&ip=' . urlencode($normalizedIP) . 
               '&api=1' . 
               '&api_key=' . urlencode($this->apiSettings['api_key']);
        
        $maxRetries = max(1, $this->apiSettings['retry_on_failure']);
        $attempt = 0;
        $lastError = null;
        
        while ($attempt < $maxRetries) {
            $attempt++;
            
            try {
                $ch = curl_init();
                
                if (!$ch) {
                    throw new Exception("Failed to initialize cURL");
                }
                
                curl_setopt_array($ch, [
                    CURLOPT_URL => $url,
                    CURLOPT_RETURNTRANSFER => true,
                    CURLOPT_TIMEOUT => $this->apiSettings['timeout'],
                    CURLOPT_CONNECTTIMEOUT => 3,
                    CURLOPT_FOLLOWLOCATION => false,
                    CURLOPT_MAXREDIRS => 0,
                    CURLOPT_SSL_VERIFYPEER => $this->apiSettings['verify_ssl'],
                    CURLOPT_SSL_VERIFYHOST => $this->apiSettings['verify_ssl'] ? 2 : 0,
                    CURLOPT_USERAGENT => $this->apiSettings['user_agent'],
                    CURLOPT_HTTPHEADER => [
                        'Accept: application/json',
                        'Cache-Control: no-cache'
                    ]
                ]);
                
                $response = curl_exec($ch);
                $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
                $curlError = curl_error($ch);
                $curlErrno = curl_errno($ch);
                
                curl_close($ch);
                
                if ($curlErrno !== 0) {
                    throw new Exception("cURL error #{$curlErrno}: {$curlError}");
                }
                
                if ($httpCode !== 200) {
                    throw new Exception("HTTP error code: {$httpCode}");
                }
                
                if (empty($response)) {
                    throw new Exception("Empty response from API");
                }
                
                $result = json_decode($response, true);
                
                if (!is_array($result)) {
                    throw new Exception("Invalid JSON response: " . substr($response, 0, 100));
                }
                
                if (isset($result['status'])) {
                    if ($result['status'] === 'success') {
                        error_log("API {$action} SUCCESS: {$normalizedIP} | " . ($result['message'] ?? 'OK'));
                        return [
                            'status' => 'success',
                            'message' => $result['message'] ?? 'Operation completed',
                            'api_response' => $result,
                            'attempt' => $attempt
                        ];
                    } elseif ($result['status'] === 'error') {
                        $errorMsg = $result['message'] ?? 'Unknown error';
                        
                        if (strpos($errorMsg, 'уже заблокирован') !== false || 
                            strpos($errorMsg, 'already blocked') !== false) {
                            return [
                                'status' => 'already_blocked',
                                'message' => $errorMsg,
                                'api_response' => $result
                            ];
                        }
                        
                        if (strpos($errorMsg, 'не заблокирован') !== false || 
                            strpos($errorMsg, 'not blocked') !== false) {
                            return [
                                'status' => 'not_blocked',
                                'message' => $errorMsg,
                                'api_response' => $result
                            ];
                        }
                        
                        throw new Exception("API error: {$errorMsg}");
                    }
                }
                
                throw new Exception("Unknown API response format");
                
            } catch (Exception $e) {
                $lastError = $e->getMessage();
                
                if ($this->apiSettings['log_api_errors']) {
                    error_log("API {$action} ATTEMPT {$attempt}/{$maxRetries} FAILED: {$normalizedIP} | {$lastError}");
                }
                
                if ($attempt < $maxRetries) {
                    usleep(200000);
                } else {
                    if ($this->apiSettings['log_api_errors']) {
                        error_log("API {$action} FINAL FAILURE: {$normalizedIP} | All {$maxRetries} attempts failed");
                    }
                }
            }
        }
        
        return [
            'status' => 'error',
            'message' => $lastError ?? 'Unknown error',
            'attempts' => $maxRetries
        ];
    }
	
    private function sendBlockResponse() {
        if (!headers_sent()) {
            // ═══════════════════════════════════════════════════════════════
            // КРИТИЧНО ДЛЯ SEO: Запрет индексации страницы блокировки
            // ═══════════════════════════════════════════════════════════════
            header('X-Robots-Tag: noindex, nofollow');
            http_response_code(429);
            header('Content-Type: text/plain; charset=utf-8');
            header('Retry-After: 900');
        }
        die('Rate limit exceeded. Please try again later.');
    }
    
    /**
     * Отправка ответа 429 при превышении rate limit (первое нарушение)
     * Отличается от sendBlockResponse - даёт шанс замедлиться
     */
    private function sendRateLimitResponse($rateLimitResult) {
        if (!headers_sent()) {
            // ═══════════════════════════════════════════════════════════════
            // КРИТИЧНО ДЛЯ SEO: Запрет индексации страницы rate limit
            // ═══════════════════════════════════════════════════════════════
            header('X-Robots-Tag: noindex, nofollow');
            http_response_code(429);
            header('Content-Type: text/plain; charset=utf-8');
            header('Retry-After: 60');  // Короткая пауза - 60 секунд
            header('X-RateLimit-Limit: ' . $this->rateLimitSettings['max_requests_per_minute']);
            header('X-RateLimit-Remaining: 0');
        }
        die('Too Many Requests. Please slow down. Retry after 60 seconds.');
    }
    
    // testRDNS() removed in optimization (saved 82 lines)
	// АДМИНИСТРАТИВНЫЕ МЕТОДЫ
    
    // getUserHashInfo() removed in optimization (saved 23 lines)
    
    public function unblockUserHash($userHash = null) {
        try {
            $userHash = $userHash ?: $this->generateUserHash();
            
            $blockKey = $this->userHashPrefix . 'blocked:' . $userHash;
            $trackingKey = $this->userHashPrefix . 'tracking:' . $userHash;
            
            $result = [
                'user_hash' => substr($userHash, 0, 16) . '...',
                'unblocked' => $this->redis->del($blockKey) > 0,
                'tracking_cleared' => $this->redis->del($trackingKey) > 0
            ];
            
            error_log("UNBLOCKED [HASH]: " . substr($userHash, 0, 8) . " | Manual");
            return $result;
        } catch (Exception $e) {
            error_log("Error unblocking user hash: " . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }
    
    // diagnoseUserHash() removed in optimization (saved 21 lines)
    
    // getUserHashStats() removed in optimization (saved 51 lines)
    
    // cleanupUserHashData() метод удален - используйте cleanup.php

    
    public function getRateLimitStats($ip) {
        try {
            $ipHash = hash('md5', $ip);
            $historyKey = $this->blockPrefix . 'history:' . $ipHash;
            $trackingKey = $this->trackingPrefix . 'ip:' . $ipHash;
            
            // Получаем текущие счётчики из атомарных ключей
            $current = time();
            $minute = floor($current / 60);
            $fiveMin = floor($current / 300);
            $hour = floor($current / 3600);
            
            $req1min = $this->redis->get($this->trackingPrefix . 'rl:1m:' . $minute . ':' . $ipHash) ?: 0;
            $req5min = $this->redis->get($this->trackingPrefix . 'rl:5m:' . $fiveMin . ':' . $ipHash) ?: 0;
            $req1hour = $this->redis->get($this->trackingPrefix . 'rl:1h:' . $hour . ':' . $ipHash) ?: 0;
            $violations = $this->redis->get($this->trackingPrefix . 'rl:violations:' . $ipHash) ?: 0;
            
            // Получаем время последнего запроса из tracking данных
            $lastRequest = 0;
            $trackingData = $this->redis->get($trackingKey);
            if ($trackingData && isset($trackingData['last_request'])) {
                $lastRequest = $trackingData['last_request'];
            }
            
            $currentStats = null;
            if ($req1min > 0 || $req5min > 0 || $req1hour > 0 || $violations > 0) {
                $currentStats = [
                    'requests_1min' => (int)$req1min,
                    'requests_5min' => (int)$req5min,
                    'requests_1hour' => (int)$req1hour,
                    'violations' => (int)$violations,
                    'last_request' => $lastRequest
                ];
            }
            
            return [
                'ip' => $ip,
                'current_stats' => $currentStats,
                'block_history' => $this->redis->get($historyKey),
                'is_blocked' => $this->isBlocked($ip),
                'extended_tracking' => false /* checkExtendedTracking removed */
            ];
        } catch (Exception $e) {
            error_log("Error getting rate limit stats: " . $e->getMessage());
            return [];
        }
    }
    
    // Функция resetRateLimit уже определена выше с улучшенной логикой (строка ~1048)
    // Эта версия удалена для избежания конфликта
    
    /**
     * УЛУЧШЕННАЯ версия: работает с новой структурой атомарных ключей
     */
    // getTopRateLimitViolators() removed in optimization (saved 71 lines)
    
    public function getStats() {
        $stats = [
            'blocked_ips' => 0,
            'blocked_cookies' => 0,
            'tracking_records' => 0,
            'rate_limit_tracking' => 0,
            'rate_limit_violations' => 0,
            'extended_tracking_active' => 0,
            'block_history_records' => 0,
            'total_keys' => 0,
            'memory_usage' => 0
        ];
        
        try {
            // ВАЖНО: OPT_PREFIX НЕ применяется к паттернам SCAN!
            // Поэтому указываем ПОЛНЫЙ путь в паттерне
            $patterns = [
                'blocked_ips' => $this->redisPrefix . $this->blockPrefix . 'ip:*',
                'blocked_cookies' => $this->redisPrefix . $this->cookiePrefix . 'blocked:*',
                'tracking_records' => $this->redisPrefix . $this->trackingPrefix . 'ip:*',
                'extended_tracking_active' => $this->redisPrefix . $this->trackingPrefix . 'extended:*',
                'block_history_records' => $this->redisPrefix . $this->blockPrefix . 'history:*',
            ];
            
            foreach ($patterns as $statKey => $pattern) {
                $count = 0;
                $iterator = null;
                do {
                    $keys = $this->redis->scan($iterator, $pattern, 100);
                    if ($keys !== false) {
                        $count += count($keys);
                    }
                } while ($iterator !== 0 && $iterator !== null);
                $stats[$statKey] = $count;
            }
            
            // Rate limit ключи с подсчетом нарушений
            $rateLimitCount = 0;
            $violations = 0;
            $iterator = null;
            $pattern = $this->redisPrefix . $this->trackingPrefix . 'rl:violations:*';
            do {
                $keys = $this->redis->scan($iterator, $pattern, 100);
                if ($keys !== false) {
                    $rateLimitCount += count($keys);
                    foreach ($keys as $key) {
                        // SCAN возвращает полный путь, убираем redisPrefix для get() (OPT_PREFIX добавит его)
                        $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                        $count = $this->redis->get($keyWithoutPrefix);
                        if ($count) {
                            $violations += intval($count);
                        }
                    }
                }
            } while ($iterator !== 0 && $iterator !== null);
            $stats['rate_limit_tracking'] = $rateLimitCount;
            $stats['rate_limit_violations'] = $violations;
            
            // Общее количество ключей через DBSIZE (быстрее чем SCAN всех)
            $stats['total_keys'] = $this->redis->dbSize();
            
            $info = $this->redis->info('memory');
            $stats['memory_usage'] = $info['used_memory_human'] ?? 'unknown';
            
            // User Hash статистика (упрощённая версия)
            $userHashBlocked = 0;
            $iterator = null;
            $pattern = $this->redisPrefix . $this->userHashPrefix . 'blocked:*';
            do {
                $keys = $this->redis->scan($iterator, $pattern, 100);
                if ($keys !== false) {
                    $userHashBlocked += count($keys);
                }
            } while ($iterator !== 0 && $iterator !== null);
            $stats['user_hash_blocked'] = $userHashBlocked;
            
        } catch (Exception $e) {
            error_log("Error getting stats: " . $e->getMessage());
        }
        
        return $stats;
    }
    
    /**
     * ═══════════════════════════════════════════════════════════════════════
     * СТАТИСТИКА ЗАПРОСОВ В РЕАЛЬНОМ ВРЕМЕНИ v1.0 (2025-12-02)
     * 
     * Эффективный подсчёт RPM (requests per minute) и RPS (requests per second)
     * с использованием атомарных операций INCR. Минимальное влияние на производительность.
     * ═══════════════════════════════════════════════════════════════════════
     */
    
    /**
     * Инкрементирует счётчик запросов
     * Вызывается в начале protect() для подсчёта всех запросов
     * 
     * Использует 2 счётчика:
     * - stats:rpm:{minute} - запросы за минуту (TTL 120 сек)
     * - stats:rps:{second} - запросы за секунду (TTL 10 сек)
     */
    public function incrementRequestCounter() {
        try {
            $now = time();
            $currentMinute = floor($now / 60);
            $currentSecond = $now;
            
            // Счётчик за минуту (TTL 120 сек для показа предыдущей минуты)
            $minuteKey = 'stats:rpm:' . $currentMinute;
            $this->redis->incr($minuteKey);
            $this->redis->expire($minuteKey, 120);
            
            // Счётчик за секунду (TTL 10 сек для скользящего окна)
            $secondKey = 'stats:rps:' . $currentSecond;
            $this->redis->incr($secondKey);
            $this->redis->expire($secondKey, 10);
            
        } catch (Exception $e) {
            // Не логируем ошибку чтобы не замедлять работу
        }
    }
    
    /**
     * Получает статистику запросов в минуту
     * 
     * @return array [
     *   'current_rpm' => int,      // Запросы за текущую минуту
     *   'previous_rpm' => int,     // Запросы за предыдущую минуту
     *   'avg_rps' => float,        // Средний RPS (на основе предыдущей минуты)
     *   'current_rps' => int,      // Мгновенный RPS (последняя секунда)
     *   'peak_rps' => int,         // Пиковый RPS за последние 10 секунд
     *   'timestamp' => int         // Время замера
     * ]
     */
    public function getRequestsPerMinute() {
        $stats = [
            'current_rpm' => 0,
            'previous_rpm' => 0,
            'avg_rps' => 0.0,
            'current_rps' => 0,
            'peak_rps' => 0,
            'timestamp' => time()
        ];
        
        try {
            $now = time();
            $currentMinute = floor($now / 60);
            $previousMinute = $currentMinute - 1;
            
            // RPM за текущую минуту
            $currentRPM = $this->redis->get('stats:rpm:' . $currentMinute);
            $stats['current_rpm'] = $currentRPM ? intval($currentRPM) : 0;
            
            // RPM за предыдущую минуту (более точный показатель)
            $previousRPM = $this->redis->get('stats:rpm:' . $previousMinute);
            $stats['previous_rpm'] = $previousRPM ? intval($previousRPM) : 0;
            
            // Средний RPS на основе предыдущей минуты
            $stats['avg_rps'] = round($stats['previous_rpm'] / 60, 2);
            
            // Мгновенный RPS (последняя полная секунда)
            $lastSecond = $now - 1;
            $currentRPS = $this->redis->get('stats:rps:' . $lastSecond);
            $stats['current_rps'] = $currentRPS ? intval($currentRPS) : 0;
            
            // Пиковый RPS за последние 10 секунд
            $peakRPS = 0;
            for ($i = 1; $i <= 10; $i++) {
                $sec = $now - $i;
                $rps = $this->redis->get('stats:rps:' . $sec);
                if ($rps && intval($rps) > $peakRPS) {
                    $peakRPS = intval($rps);
                }
            }
            $stats['peak_rps'] = $peakRPS;
            
        } catch (Exception $e) {
            error_log("Error getting request stats: " . $e->getMessage());
        }
        
        return $stats;
    }
    
    /**
     * Получает историю RPM за последние N минут
     * 
     * @param int $minutes Количество минут (по умолчанию 5)
     * @return array Массив с RPM за каждую минуту
     */
    // getRPMHistory() removed in optimization (saved 23 lines)
    
    // cleanup() метод удален - используйте cleanup.php

    
    // deepCleanup() метод удален - используйте cleanup.php

    
    /**
     * ═══════════════════════════════════════════════════════════════════════
     * ОБНОВЛЕННЫЙ МЕТОД unblockIP() v2.4
     * 
     * Теперь сбрасывает ВСЁ: блокировку, violations, rate limit счётчики
     * ═══════════════════════════════════════════════════════════════════════
     */
    public function unblockIP($ip) {
    try {
        $ipHash = hash('md5', $ip);
        $blockKey = $this->blockPrefix . 'ip:' . $ipHash;
        $trackingKey = $this->trackingPrefix . 'ip:' . $ipHash;
        $extendedKey = $this->trackingPrefix . 'extended:' . $ipHash;
        $violationsKey = $this->trackingPrefix . 'violations:' . $ipHash;
        
        $result = [
            'ip_unblocked' => false,
            'tracking_cleared' => false,
            'extended_tracking_cleared' => false,
            'violations_cleared' => false,
            'rate_limit_cleared' => false,
            'api_unblocked' => false,
            'api_message' => null
        ];
        
        // Разблокировка в Redis
        if ($this->apiSettings['block_on_redis']) {
            $result['ip_unblocked'] = $this->redis->del($blockKey) > 0;
            $result['tracking_cleared'] = $this->redis->del($trackingKey) > 0;
            $result['extended_tracking_cleared'] = $this->redis->del($extendedKey) > 0;
        }
        
        // НОВОЕ v2.4: Сброс violations
        $result['violations_cleared'] = $this->redis->del($violationsKey) > 0;
        
        // НОВОЕ v2.4: Сброс rate limit счётчиков
        $current = time();
        $minute = floor($current / 60);
        $fiveMin = floor($current / 300);
        $hour = floor($current / 3600);
        
        $keysToDelete = [
            $this->trackingPrefix . 'rl:1m:' . $minute . ':' . $ipHash,
            $this->trackingPrefix . 'rl:5m:' . $fiveMin . ':' . $ipHash,
            $this->trackingPrefix . 'rl:1h:' . $hour . ':' . $ipHash,
            $this->trackingPrefix . 'rl:violations:' . $ipHash,
            $this->trackingPrefix . 'burst:' . $ipHash,
            $this->trackingPrefix . 'burst_warn:' . $ipHash,
        ];
        
        $rlDeleted = 0;
        foreach ($keysToDelete as $key) {
            $rlDeleted += $this->redis->del($key);
        }
        $result['rate_limit_cleared'] = $rlDeleted > 0;
        
        // Разблокировка через API (если включена автоматическая разблокировка)
        if ($this->apiSettings['auto_unblock'] && $this->apiSettings['block_on_api']) {
            $apiResult = $this->callBlockingAPI($ip, 'unblock');
            
            if ($apiResult['status'] === 'success' || $apiResult['status'] === 'not_blocked') {
                $result['api_unblocked'] = true;
                $result['api_message'] = $apiResult['message'];
                error_log("UNBLOCKED [IP]: $ip | API+Redis+Violations | Manual");
            } else {
                $result['api_unblocked'] = false;
                $result['api_message'] = $apiResult['message'] ?? 'API call failed';
                error_log("UNBLOCKED [IP]: $ip | Redis+Violations only (API failed) | Manual");
            }
        } else {
            error_log("UNBLOCKED [IP]: $ip | Redis+Violations only | Manual");
        }
        
        return $result;
    } catch (Exception $e) {
        error_log("Error unblocking IP: " . $e->getMessage());
        return ['error' => $e->getMessage()];
    }
}
    
    public function getBlockedIPInfo($ip) {
        try {
            $ipHash = hash('md5', $ip);
            $blockKey = $this->blockPrefix . 'ip:' . $ipHash;
            $trackingKey = $this->trackingPrefix . 'ip:' . $ipHash;
            $extendedKey = $this->trackingPrefix . 'extended:' . $ipHash;
            $violationsKey = $this->trackingPrefix . 'violations:' . $ipHash;
            
            return [
                'blocked' => $this->redis->exists($blockKey),
                'block_data' => $this->redis->get($blockKey),
                'tracking_data' => $this->redis->get($trackingKey),
                'extended_tracking' => $this->redis->get($extendedKey),
                'violations' => $this->getTotalViolations($ip),
                'ttl' => $this->redis->ttl($blockKey)
            ];
        } catch (Exception $e) {
            error_log("Error getting blocked IP info: " . $e->getMessage());
            return [];
        }
    }
    
    public function getTTLSettings() {
        return $this->ttlSettings;
    }
    
    public function getSlowBotSettings() {
        return $this->slowBotSettings;
    }
    
    public function getRateLimitSettings() {
        return $this->rateLimitSettings;
    }
    
    public function getGlobalProtectionSettings() {
        return $this->globalProtectionSettings;
    }
    
    public function updateTTLSettings($newSettings) {
        $this->ttlSettings = array_merge($this->ttlSettings, $newSettings);
        error_log("TTL settings updated: " . json_encode($newSettings));
    }
    
	/**
 * Обновить настройки API
 */
public function updateAPISettings($newSettings) {
    $this->apiSettings = array_merge($this->apiSettings, $newSettings);
    error_log("API settings updated: " . json_encode($newSettings));
}

/**
 * Получить настройки API
 */
public function getAPISettings() {
    return $this->apiSettings;
}

/**
 * Тестирование API подключения
 */
public function testAPIConnection() {
    if (!$this->apiSettings['enabled']) {
        return [
            'status' => 'disabled',
            'message' => 'API integration is disabled'
        ];
    }
    
    // Получаем список заблокированных IP для теста подключения
    $url = $this->apiSettings['url'] . 
           '?action=list&api=1&api_key=' . urlencode($this->apiSettings['api_key']);
    
    try {
        $ch = curl_init();
        curl_setopt_array($ch, [
            CURLOPT_URL => $url,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_TIMEOUT => $this->apiSettings['timeout'],
            CURLOPT_SSL_VERIFYPEER => $this->apiSettings['verify_ssl'],
            CURLOPT_SSL_VERIFYHOST => $this->apiSettings['verify_ssl'] ? 2 : 0,
        ]);
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        
        if ($httpCode === 200) {
            $result = json_decode($response, true);
            if (isset($result['status']) && $result['status'] === 'success') {
                return [
                    'status' => 'success',
                    'message' => 'API connection successful',
                    'api_response' => $result
                ];
            }
        }
        
        return [
            'status' => 'error',
            'message' => "API returned HTTP {$httpCode}",
            'response' => substr($response, 0, 200)
        ];
        
    } catch (Exception $e) {
        return [
            'status' => 'error',
            'message' => $e->getMessage()
        ];
    }
}

/**
 * Принудительная синхронизация: блокировать в API все IP, заблокированные в Redis
 */
public function syncBlockedIPsToAPI() {
    if (!$this->apiSettings['enabled'] || !$this->apiSettings['block_on_api']) {
        return [
            'status' => 'disabled',
            'message' => 'API integration is disabled'
        ];
    }
    
    try {
        // ВАЖНО: OPT_PREFIX НЕ применяется к паттернам SCAN - указываем полный путь
        $pattern = $this->redisPrefix . $this->blockPrefix . 'ip:*';
        $iterator = null;
        $synced = 0;
        $failed = 0;
        
        do {
            $keys = $this->redis->scan($iterator, $pattern, 100);
            
            if ($keys === false) break;
            
            foreach ($keys as $key) {
                // SCAN возвращает полный путь, убираем redisPrefix
                $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                $blockData = $this->redis->get($keyWithoutPrefix);
                
                if ($blockData && isset($blockData['ip'])) {
                    $ip = $blockData['ip'];
                    
                    // Пропускаем, если уже заблокирован через API
                    if (isset($blockData['api_blocked']) && $blockData['api_blocked']) {
                        continue;
                    }
                    
                    $apiResult = $this->callBlockingAPI($ip, 'block');
                    
                    if ($apiResult['status'] === 'success' || $apiResult['status'] === 'already_blocked') {
                        $synced++;
                        
                        // Обновляем данные в Redis
                        $blockData['api_blocked'] = true;
                        $blockData['api_synced_at'] = time();
                        $ttl = $this->redis->ttl($keyWithoutPrefix);
                        if ($ttl > 0) {
                            $this->redis->setex($keyWithoutPrefix, $ttl, $blockData);
                        }
                    } else {
                        $failed++;
                    }
                    
                    usleep(100000); // 100ms задержка между запросами
                }
            }
            
        } while ($iterator > 0);
        
        error_log("API SYNC: Synced {$synced} IPs to API, {$failed} failed");
        
        return [
            'status' => 'success',
            'synced' => $synced,
            'failed' => $failed,
            'message' => "Synced {$synced} blocked IPs to API"
        ];
        
    } catch (Exception $e) {
        error_log("Error in syncBlockedIPsToAPI: " . $e->getMessage());
        return [
            'status' => 'error',
            'message' => $e->getMessage()
        ];
    }
}
	
    public function updateSlowBotSettings($newSettings) {
        $this->slowBotSettings = array_merge($this->slowBotSettings, $newSettings);
        error_log("Slow bot settings updated: " . json_encode($newSettings));
    }
    
    public function updateRateLimitSettings($newSettings) {
        $this->rateLimitSettings = array_merge($this->rateLimitSettings, $newSettings);
        error_log("Rate limit settings updated: " . json_encode($newSettings));
    }
    
    public function updateGlobalProtectionSettings($newSettings) {
        $this->globalProtectionSettings = array_merge($this->globalProtectionSettings, $newSettings);
        error_log("Global protection settings updated: " . json_encode($newSettings));
    }
    
    public function getRedisMemoryInfo() {
        try {
            // ОПТИМИЗИРОВАНО: читаем метрики из cleanup.php вместо множественных запросов
            $metrics = $this->redis->get($this->globalPrefix . 'metrics');
            
            if ($metrics && is_array($metrics)) {
                return [
                    'tracked_ips_count' => isset($metrics['tracked_ips']) ? $metrics['tracked_ips'] : 0,
                    'blocked_ips_count' => isset($metrics['blocked_ips']) ? $metrics['blocked_ips'] : 0,
                    'blocked_hashes_count' => isset($metrics['blocked_hashes']) ? $metrics['blocked_hashes'] : 0,
                    'rdns_cache_size' => isset($metrics['rdns_cache_size']) ? $metrics['rdns_cache_size'] : 0,
                    'cleanup_threshold' => $this->globalProtectionSettings['cleanup_threshold'],
                    'cleanup_needed' => isset($metrics['tracked_ips']) ? 
                        ($metrics['tracked_ips'] > $this->globalProtectionSettings['cleanup_threshold']) : false,
                    'last_cleanup' => isset($metrics['last_cleanup']) ? $metrics['last_cleanup'] : 0,
                    'last_cleanup_ago' => isset($metrics['last_cleanup']) ? 
                        (time() - $metrics['last_cleanup']) : null
                ];
            }
            
            // Fallback: если метрик нет, используем счетчик (cleanup.php еще не запускался)
            $counterKey = $this->globalPrefix . 'tracked_counter';
            $trackedCount = $this->redis->get($counterKey) ?: 0;
            
            return [
                'tracked_ips_count' => $trackedCount,
                'blocked_ips_count' => 0,
                'blocked_hashes_count' => 0,
                'rdns_cache_size' => 0,
                'cleanup_threshold' => $this->globalProtectionSettings['cleanup_threshold'],
                'cleanup_needed' => $trackedCount >= $this->globalProtectionSettings['cleanup_threshold'],
                'last_cleanup' => 0,
                'last_cleanup_ago' => null,
                'warning' => 'Metrics not available - ensure cleanup.php is running via cron'
            ];
        } catch (Exception $e) {
            error_log("Error getting Redis memory info: " . $e->getMessage());
            return [];
        }
    }
    
    // forceCleanup() метод удален - используйте cleanup.php

    
    
    /**
     * НОВЫЙ МЕТОД: Проверка статуса cleanup.php
     * Показывает когда последний раз запускался cleanup.php и его состояние
     */
    public function getCleanupStatus() {
        try {
            $metrics = $this->redis->get($this->globalPrefix . 'metrics');
            
            if (!$metrics || !isset($metrics['last_cleanup'])) {
                return [
                    'status' => 'never_run',
                    'message' => 'cleanup.php never executed or metrics not available',
                    'recommendation' => 'Setup cron: */5 * * * * php /path/to/cleanup.php >> /var/log/cleanup.log 2>&1',
                    'critical' => true
                ];
            }
            
            $lastCleanup = $metrics['last_cleanup'];
            $timeSince = time() - $lastCleanup;
            $minutesAgo = round($timeSince / 60);
            
            if ($timeSince > 1800) { // 30 минут
                return [
                    'status' => 'warning',
                    'message' => "cleanup.php not run for {$minutesAgo} minutes",
                    'last_run' => date('Y-m-d H:i:s', $lastCleanup),
                    'minutes_ago' => $minutesAgo,
                    'recommendation' => 'Check if cron is working: crontab -l | grep cleanup',
                    'critical' => $timeSince > 3600 // Критично если > 1 часа
                ];
            }
            
            return [
                'status' => 'ok',
                'message' => 'cleanup.php running normally',
                'last_run' => date('Y-m-d H:i:s', $lastCleanup),
                'minutes_ago' => $minutesAgo,
                'metrics' => $metrics,
                'critical' => false
            ];
        } catch (Exception $e) {
            error_log("Error checking cleanup status: " . $e->getMessage());
            return [
                'status' => 'error',
                'message' => $e->getMessage(),
                'critical' => true
            ];
        }
    }
    
    /**
     * ═══════════════════════════════════════════════════════════════════════
     * JS CHALLENGE МЕТОДЫ
     * ═══════════════════════════════════════════════════════════════════════
     */
    
    /**
     * Проверка JS Challenge
     * Определяет нужно ли показать challenge и есть ли валидный токен
     */
    private function checkJSChallenge($ip) {
        // Проверяем исключен ли текущий URL из JS Challenge
        if ($this->isExcludedFromJSChallenge()) {
            return [
                'show_challenge' => false,
                'has_valid_token' => true, // Считаем как будто есть токен
                'reason' => 'URL excluded from JS Challenge',
                'excluded' => true
            ];
        }
        
        $result = [
            'show_challenge' => false,
            'has_valid_token' => false,
            'reason' => null
        ];
        
        // Проверяем есть ли валидный токен
        if ($this->hasValidJSToken($ip)) {
            $result['has_valid_token'] = true;
            return $result; // Токен валидный - не показываем challenge
        }
        
        // Проверяем триггеры для показа challenge
        
        // 1. Высокие violations
        if ($this->jsChallengeSettings['trigger_on_high_violations']) {
            $violations = $this->getTotalViolations($ip);
            if ($violations['total'] >= $this->jsChallengeSettings['violations_threshold']) {
                $result['show_challenge'] = true;
                $result['reason'] = "High violations: {$violations['total']}";
                return $result;
            }
        }
        
        // 2. Slow bot detection
        if ($this->jsChallengeSettings['trigger_on_slow_bot']) {
            $trackingData = $this->getUserTrackingData($ip);
            if ($trackingData && $this->isPotentialSlowBot($trackingData)) {
                $result['show_challenge'] = true;
                $result['reason'] = 'Slow bot pattern detected';
                return $result;
            }
        }
        
        // 3. Нет cookie - показываем ВСЕМ при первом запросе
        if ($this->jsChallengeSettings['trigger_on_no_cookie']) {
            $trackingData = $this->getUserTrackingData($ip);
            $hasCookie = $this->hasValidCookie();
            
            // НОВАЯ ЛОГИКА: показываем Challenge ВСЕМ без cookie (при первом запросе)
            if (!$hasCookie) {
                $result['show_challenge'] = true;
                $result['reason'] = "No cookie (requests: " . ($trackingData['requests'] ?? 0) . ")";
                return $result;
            }
        }
        
        return $result;
    }
    
    
    /**
     * Проверка, исключён ли текущий URL из JS Challenge
     * Поддерживает wildcard паттерны с *
     * 
     * @return bool True если URL исключен из проверки
     */
    private function isExcludedFromJSChallenge() {
        $excludedUrls = $this->jsChallengeSettings['excluded_urls'] ?? [];
        
        if (empty($excludedUrls)) {
            return false;
        }
        
        $currentUri = $_SERVER['REQUEST_URI'] ?? '/';
        
        foreach ($excludedUrls as $pattern) {
            if ($this->matchUrlPattern($currentUri, $pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Проверка соответствия URL паттерну с поддержкой wildcard (*)
     * 
     * @param string $url Проверяемый URL
     * @param string $pattern Паттерн с возможными * (wildcard)
     * @return bool True если URL соответствует паттерну
     */
    private function matchUrlPattern($url, $pattern) {
        // Точное совпадение
        if ($url === $pattern) {
            return true;
        }
        
        // Если паттерн не содержит *, проверяем только точное совпадение
        if (strpos($pattern, '*') === false) {
            return false;
        }
        
        // Экранируем специальные символы regex, кроме *
        $pattern = preg_quote($pattern, '/');
        
        // Заменяем экранированные \* на .* для regex
        $pattern = str_replace('\*', '.*', $pattern);
        
        // Проверяем совпадение
        return preg_match('/^' . $pattern . '$/', $url) === 1;
    }
    
    /**
     * Проверка валидности JS Challenge токена
     */
    private function hasValidJSToken($ip) {
        $tokenName = $this->jsChallengeSettings['token_name'];
        
        if (!isset($_COOKIE[$tokenName])) {
            return false;
        }
        
        $token = $_COOKIE[$tokenName];
        
        try {
            $tokenKey = 'js_challenge:token:' . hash('md5', $token);
            $tokenData = $this->redis->get($tokenKey);
            
            if (!$tokenData || !is_array($tokenData)) {
                return false;
            }
            
            // Проверяем IP совпадает
            if (($tokenData['ip'] ?? '') !== $ip) {
                return false;
            }
            
            // Проверяем не истёк ли токен
            $createdAt = $tokenData['created_at'] ?? 0;
            $ttl = $this->jsChallengeSettings['token_ttl'];
            
            if ((time() - $createdAt) > $ttl) {
                // Токен истёк
                $this->redis->del($tokenKey);
                return false;
            }
            
            return true;
            
        } catch (Exception $e) {
            error_log("Error checking JS token: " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Отображение JS Challenge страницы
     */
    private function showJSChallenge($reason = 'Security check required') {
        // Сохраняем информацию о показе challenge
        $this->logChallengeShown($this->getRealIP(), $reason);
        
        $originalUrl = $_SERVER['REQUEST_URI'] ?? '/';
        $difficulty = $this->jsChallengeSettings['pow_difficulty'];
        $minTime = $this->jsChallengeSettings['min_solve_time'];
        
        if (!headers_sent()) {
            http_response_code(403);
            header('Content-Type: text/html; charset=utf-8');
            header('X-Robots-Tag: noindex, nofollow');
        }
        
        $html = <<<'HTML'
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <meta name="googlebot" content="noindex, nofollow">
    <title>Проверяем браузер перед переходом на сайт…</title>
    <style>
        :root {
            --bg: #0d0d0d;
            --fg: #fff;
            --muted: #bbb;
            --accent: #fa357a;
            --spinner: #667eea;
        }
        
        html, body {
            margin: 0;
            height: 100%;
            background: var(--bg);
            color: var(--fg);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }
        
        .box {
            min-height: 100svh;
            min-height: 100dvh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: clamp(12px, 3vw, 24px);
            box-sizing: border-box;
        }
        
        .inner {
            max-width: min(640px, 92vw);
            text-align: center;
        }
        
        .spinner {
            width: clamp(36px, 8vmin, 64px);
            height: clamp(36px, 8vmin, 64px);
            margin: 0 auto 16px;
        }
        
        .spinner svg {
            width: 100%;
            height: 100%;
            animation: rot 1s linear infinite;
        }
        
        @keyframes rot {
            to { transform: rotate(360deg); }
        }
        
        .title {
            font-size: clamp(18px, 4.5vw, 24px);
            font-weight: 700;
            margin: 12px 0 6px;
            line-height: 1.35;
        }
        
        .desc {
            color: var(--muted);
            font-size: clamp(14px, 3.8vw, 18px);
            line-height: 1.55;
        }
        
        .heart {
            color: var(--accent);
            margin-left: 4px;
            display: inline-block;
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1); }
            50% { transform: scale(1); }
        }
        
        .checks {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: none; /* Скрыто по умолчанию */
        }
        
        .check-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            font-size: clamp(13px, 3.2vw, 15px);
            color: var(--muted);
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }
        
        .check-item.done {
            opacity: 1;
            color: var(--fg);
        }
        
        .check-icon {
            font-size: 16px;
            margin-left: 8px;
        }
        
        .error {
            background: rgba(250, 53, 122, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 16px;
            font-size: clamp(13px, 3.2vw, 14px);
            display: none;
        }
        
        noscript {
            display: block;
            color: var(--accent);
            font-size: clamp(13px, 3.2vw, 15px);
            margin-top: 16px;
            padding: 12px;
            background: rgba(250, 53, 122, 0.1);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="box">
        <div class="inner">
            <div class="spinner">
                <svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" 
                            stroke-width="4" stroke-linecap="round" 
                            stroke-dasharray="31.4 31.4" 
                            style="color: var(--spinner); opacity: 0.3;"/>
                    <circle cx="25" cy="25" r="20" fill="none" stroke="currentColor" 
                            stroke-width="4" stroke-linecap="round" 
                            stroke-dasharray="15.7 94.2"
                            style="color: var(--spinner);"/>
                </svg>
            </div>
            
            <div class="title">Проверяем браузер перед переходом на сайт…</div>
            <div class="desc" id="status">Это не занимает много времени, пожалуйста, подождите<span class="heart">❤</span></div>
            
            <div class="checks" id="checks">
                <div class="check-item" id="check-js">
                    <span>JavaScript</span>
                    <span class="check-icon">⏳</span>
                </div>
                <div class="check-item" id="check-canvas">
                    <span>Canvas</span>
                    <span class="check-icon">⏳</span>
                </div>
                <div class="check-item" id="check-webgl">
                    <span>WebGL</span>
                    <span class="check-icon">⏳</span>
                </div>
                <div class="check-item" id="check-timing">
                    <span>Timing</span>
                    <span class="check-icon">⏳</span>
                </div>
                <div class="check-item" id="check-pow">
                    <span>Security</span>
                    <span class="check-icon">⏳</span>
                </div>
                <div class="check-item" id="check-behavior">
                    <span>Behavior</span>
                    <span class="check-icon">⏳</span>
                </div>
            </div>
            
            <div class="error" id="error"></div>
            
            <noscript>
                ⚠️ Пожалуйста, включите JavaScript для продолжения
            </noscript>
        </div>
    </div>

    <script>
HTML;
        
        $html .= "\n        const startTime = Date.now();\n";
        $html .= "        const minTime = {$minTime};\n";
        $html .= "        const difficulty = {$difficulty};\n";
        $html .= "        const originalUrl = '" . addslashes($originalUrl) . "';\n";
        
        $html .= <<<'JAVASCRIPT'
        
        let checks = {
            js: false,
            canvas: false,
            webgl: false,
            timing: false,
            pow: false,
            behavior: false
        };
        
        let checksData = {};
        
        function updateProgress() {
            const total = Object.keys(checks).length;
            const completed = Object.values(checks).filter(v => v).length;
            
            // Показываем панель с чекбоксами после первой проверки
            if (completed > 0) {
                document.getElementById('checks').style.display = 'block';
            }
            
            // Обновляем статус
            if (completed === total) {
                document.getElementById('status').innerHTML = 'Завершаем проверку<span class="heart">❤</span>';
                submitChallenge();
            } else {
                document.getElementById('status').innerHTML = `Проверяем безопасность (${completed}/${total})<span class="heart">❤</span>`;
            }
        }
        
        function markCheckDone(checkId) {
            const el = document.getElementById('check-' + checkId);
            if (el) {
                el.classList.add('done');
                el.querySelector('.check-icon').textContent = '✓';
            }
        }
        
        function checkJS() {
            setTimeout(() => {
                checksData.js = {
                    hasLocalStorage: typeof(Storage) !== "undefined",
                    hasSessionStorage: typeof(sessionStorage) !== "undefined",
                    hasCookies: navigator.cookieEnabled,
                    userAgent: navigator.userAgent
                };
                
                checks.js = true;
                markCheckDone('js');
                updateProgress();
                checkCanvas();
            }, 100);
        }
        
        function checkCanvas() {
            setTimeout(() => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 200;
                    canvas.height = 50;
                    
                    ctx.textBaseline = 'top';
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#f60';
                    ctx.fillRect(0, 0, 200, 50);
                    ctx.fillStyle = '#069';
                    ctx.fillText('Security Check 🛡️', 2, 15);
                    
                    const dataURL = canvas.toDataURL();
                    checksData.canvas = simpleHash(dataURL);
                    
                    checks.canvas = true;
                    markCheckDone('canvas');
                    updateProgress();
                    checkWebGL();
                } catch(e) {
                    checksData.canvas = 'error';
                    checks.canvas = true;
                    markCheckDone('canvas');
                    updateProgress();
                    checkWebGL();
                }
            }, 150);
        }
        
        function checkWebGL() {
            setTimeout(() => {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        checksData.webgl = {
                            vendor: gl.getParameter(gl.VENDOR),
                            renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown'
                        };
                    } else {
                        checksData.webgl = 'not_supported';
                    }
                    
                    checks.webgl = true;
                    markCheckDone('webgl');
                    updateProgress();
                    checkTiming();
                } catch(e) {
                    checksData.webgl = 'error';
                    checks.webgl = true;
                    markCheckDone('webgl');
                    updateProgress();
                    checkTiming();
                }
            }, 200);
        }
        
        function checkTiming() {
            setTimeout(() => {
                const elapsed = Date.now() - startTime;
                checksData.timing = {
                    elapsed: elapsed,
                    performance: performance.now()
                };
                
                checks.timing = true;
                markCheckDone('timing');
                updateProgress();
                checkPoW();
            }, 100);
        }
        
        function checkPoW() {
            // ПРОСТАЯ ВЕРСИЯ: устанавливаем fallback сразу
            // Это гарантирует что checksData.pow будет объектом, а не undefined
            checksData.pow = {
                challenge: 'simple',
                nonce: 0,
                hash: '000fallback',
                time: Date.now() - startTime,
                fallback: true
            };
            
            checks.pow = true;
            markCheckDone('pow');
            
            console.log('PoW: Using simplified fallback mode');
            
            updateProgress();
            checkBehavior();
        }
        
        function checkBehavior() {
            setTimeout(() => {
                checksData.behavior = {
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        colorDepth: screen.colorDepth
                    },
                    language: navigator.language,
                    platform: navigator.platform,
                    hardwareConcurrency: navigator.hardwareConcurrency || 0,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };
                
                checks.behavior = true;
                markCheckDone('behavior');
                updateProgress();
            }, 100);
        }
        
        function simpleHash(str) {
            let hash = 2166136261;
            for (let i = 0; i < str.length; i++) {
                hash ^= str.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            }
            return (hash >>> 0).toString(16);
        }
        
        function submitChallenge() {
            const totalTime = Date.now() - startTime;
            
            if (totalTime < minTime) {
                const waitTime = minTime - totalTime;
                document.getElementById('status').innerHTML = 'Завершаем проверку<span class="heart">❤</span>';
                
                setTimeout(() => {
                    actualSubmit();
                }, waitTime);
            } else {
                actualSubmit();
            }
        }
        
        function actualSubmit() {
            document.getElementById('status').innerHTML = 'Перенаправление...<span class="heart">❤</span>';
            
            const data = {
                checks: checks,
                data: checksData,
                totalTime: Date.now() - startTime,
                originalUrl: originalUrl
            };
            
            // DEBUG: Выводим что отправляем
            console.log('JS Challenge: Submitting data', data);
            console.log('JS Challenge: PoW data', checksData.pow);
            
            fetch('?js_challenge_verify=1', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(result => {
                console.log('JS Challenge: Server response', result);
                if (result.success) {
                    window.location.href = result.redirect || originalUrl;
                } else {
                    showError(result.message || 'Verification failed');
                }
            })
            .catch(error => {
                console.error('JS Challenge: Network error', error);
                showError('Network error: ' + error.message);
            });
        }
        
        function showError(message) {
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
            document.getElementById('status').innerHTML = 'Ошибка проверки<span class="heart">❤</span>';
        }
        
        setTimeout(() => {
            checkJS();
        }, 500);
    </script>
</body>
</html>
JAVASCRIPT;
        
        die($html);
    }
    
    /**
     * Верификация JS Challenge (обрабатывает POST запрос)
     */
    public function verifyJSChallenge() {
        if (!isset($_GET['js_challenge_verify']) || $_GET['js_challenge_verify'] !== '1') {
            return false;
        }
        
        $input = file_get_contents('php://input');
        $data = json_decode($input, true);
        
        if (!$data || !isset($data['checks'], $data['data'], $data['totalTime'])) {
            error_log("JS CHALLENGE DEBUG: Invalid data received - " . substr($input, 0, 200));
            $this->sendJSONResponse(['success' => false, 'message' => 'Invalid data']);
            return true;
        }
        
        $ip = $this->getRealIP();
        $totalTime = $data['totalTime'];
        $checks = $data['checks'];
        $checksData = $data['data'];
        
        // DEBUG: Логируем что получили
        error_log("JS CHALLENGE DEBUG: $ip | Received checks: " . json_encode($checks));
        error_log("JS CHALLENGE DEBUG: $ip | PoW data: " . json_encode($checksData['pow'] ?? 'MISSING'));
        
        $errors = [];
        
        // Проверка всех checks
        foreach ($checks as $check => $status) {
            if (!$status) {
                $errors[] = "Check '$check' not completed";
            }
        }
        
        // Проверка минимального времени
        $minTime = $this->jsChallengeSettings['min_solve_time'];
        if ($totalTime < $minTime) {
            $errors[] = "Completed too fast: {$totalTime}ms < {$minTime}ms";
        }
        
        // Проверка PoW (ОПЦИОНАЛЬНАЯ - не блокирует если не работает)
        if (isset($checksData['pow']) && is_array($checksData['pow'])) {
            $pow = $checksData['pow'];
            $challenge = $pow['challenge'] ?? '';
            $nonce = $pow['nonce'] ?? 0;
            $hash = $pow['hash'] ?? '';
            $isFallback = isset($pow['fallback']) && $pow['fallback'] === true;
            
            // Если это fallback вариант (не нашли решение) - разрешаем
            if ($isFallback) {
                error_log("JS CHALLENGE: $ip | PoW fallback used (difficulty too high or slow device)");
                // Fallback разрешён - пропускаем проверку
            } else {
                // Обычная проверка PoW
                $expectedHash = $this->simpleHashPHP($challenge . $nonce);
                $difficulty = $this->jsChallengeSettings['pow_difficulty'];
                $targetPrefix = str_repeat('0', $difficulty);
                
                if ($hash !== $expectedHash) {
                    error_log("JS CHALLENGE: $ip | PoW hash mismatch (non-critical)");
                }
                
                if (substr($hash, 0, $difficulty) !== $targetPrefix) {
                    error_log("JS CHALLENGE: $ip | PoW difficulty not met (non-critical)");
                }
            }
        } else {
            // PoW данные отсутствуют - НЕ критично, пропускаем
            error_log("JS CHALLENGE: $ip | PoW data missing (skipped, other checks passed)");
        }
        
        // Проверка canvas fingerprint
        if (empty($checksData['canvas']) || $checksData['canvas'] === 'error') {
            $errors[] = "Canvas fingerprint invalid";
        }
        
        if (!empty($errors)) {
            error_log("JS CHALLENGE FAILED: $ip | Errors: " . implode(', ', $errors));
            
            // ═══════════════════════════════════════════════════════════════
            // НОВАЯ ЗАЩИТА: Считаем провалы и блокируем при превышении
            // ═══════════════════════════════════════════════════════════════
            $failuresKey = $this->trackingPrefix . 'js_challenge_failures:' . hash('md5', $ip);
            $failures = (int)$this->redis->get($failuresKey);
            $failures++;
            $this->redis->setex($failuresKey, 3600, $failures); // TTL 1 час
            
            // АДАПТИВНАЯ ЗАЩИТА v2.8.0: Используем динамический порог
            $failureThreshold = $this->getAdaptiveThreshold();
            
            if ($failures >= $failureThreshold) {
                $mode = $this->jsChallengeSettings['adaptive_protection'] ? 
                    ($failureThreshold === 1 ? 'ATTACK MODE' : 'NORMAL MODE') : 
                    'STATIC MODE';
                error_log("JS CHALLENGE: $ip | Failed $failures times → BLOCKING via API! [$mode, threshold=$failureThreshold]");
                
                // Блокируем через API (iptables)
                $blockReason = "JS Challenge failed $failures times (bot detected)";
                $this->applyProgressiveBlock($ip, $blockReason, [
                    'js_challenge_failures' => $failures,
                    'last_errors' => $errors,
                    'adaptive_mode' => $mode,
                    'adaptive_threshold' => $failureThreshold
                ]);
                
                // Блокируем user hash
                $this->blockUserHash($blockReason);
                
                // Отправляем ответ с блокировкой
                $this->sendJSONResponse([
                    'success' => false,
                    'message' => 'Too many failed attempts. Your IP has been blocked.',
                    'blocked' => true
                ]);
                return true;
            }
            
            // Ещё не достигли порога - просто отказываем
            $this->sendJSONResponse([
                'success' => false,
                'message' => 'Verification failed: ' . implode(', ', $errors),
                'attempts_left' => $failureThreshold - $failures
            ]);
            return true;
        }
        
        // Создаём токен
        $token = bin2hex(random_bytes(16));
        $tokenKey = 'js_challenge:token:' . hash('md5', $token);
        
        $tokenData = [
            'ip' => $ip,
            'created_at' => time(),
            'checks' => $checks,
            'fingerprint' => [
                'canvas' => $checksData['canvas'] ?? null,
                'webgl' => $checksData['webgl'] ?? null,
                'behavior' => $checksData['behavior'] ?? null
            ],
            'solve_time' => $totalTime
        ];
        
        try {
            $ttl = $this->jsChallengeSettings['token_ttl'];
            $this->redis->setex($tokenKey, $ttl, $tokenData);
            
            $tokenName = $this->jsChallengeSettings['token_name'];
            $secure = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';
            setcookie($tokenName, $token, time() + $ttl, '/', '', $secure, true);
            
            $this->setVisitorCookie();
            
            $violationsKey = $this->trackingPrefix . 'violations:' . hash('md5', $ip);
            $this->redis->del($violationsKey);
            
            error_log("JS CHALLENGE PASSED: $ip | Time: {$totalTime}ms");
            $this->incrementJSStat('js_challenge_passed');
            
            $originalUrl = $data['originalUrl'] ?? '/';
            $this->sendJSONResponse([
                'success' => true,
                'message' => 'Verification successful',
                'redirect' => $originalUrl
            ]);
            
        } catch (Exception $e) {
            error_log("Error creating JS token: " . $e->getMessage());
            $this->sendJSONResponse([
                'success' => false,
                'message' => 'Server error'
            ]);
        }
        
        return true;
    }
    
    /**
     * Простая хеш функция (FNV-1a) - PHP версия
     */
    private function simpleHashPHP($str) {
        $hash = 2166136261;
        $len = strlen($str);
        
        for ($i = 0; $i < $len; $i++) {
            $hash ^= ord($str[$i]);
            $hash += ($hash << 1) + ($hash << 4) + ($hash << 7) + ($hash << 8) + ($hash << 24);
            $hash &= 0xFFFFFFFF;
        }
        
        return dechex($hash);
    }
    
    /**
     * Отправка JSON ответа
     */
    private function sendJSONResponse($data) {
        if (!headers_sent()) {
            header('Content-Type: application/json');
        }
        die(json_encode($data));
    }
    
    /**
     * Логирование показа challenge
     */
    private function logChallengeShown($ip, $reason) {
        try {
            $this->incrementJSStat('js_challenge_shown');
            
            $reasonKey = 'js_challenge:reason:' . hash('md5', $ip);
            $this->redis->setex($reasonKey, 300, [
                'reason' => $reason,
                'time' => time(),
                'ip' => $ip
            ]);
            
        } catch (Exception $e) {
            error_log("Error logging challenge: " . $e->getMessage());
        }
    }
    
    /**
     * Инкремент статистики JS Challenge
     */
    private function incrementJSStat($statName) {
        try {
            $statsKey = 'js_challenge:stats';
            $this->redis->hincrby($statsKey, $statName, 1);
            
            $todayKey = 'js_challenge:stats:' . date('Y-m-d');
            $this->redis->hincrby($todayKey, $statName, 1);
            $this->redis->expire($todayKey, 604800);
            
        } catch (Exception $e) {
            // Не критично
        }
    }
    
    /**
     * Получить статистику JS Challenge
     */
    public function getJSChallengeStats() {
        try {
            $stats = [
                'total_shown' => 0,
                'total_passed' => 0,
                'today_shown' => 0,
                'today_passed' => 0,
                'active_tokens' => 0,
                'success_rate' => 0
            ];
            
            $allTimeStats = $this->redis->hgetall('js_challenge:stats');
            $stats['total_shown'] = (int)($allTimeStats['js_challenge_shown'] ?? 0);
            $stats['total_passed'] = (int)($allTimeStats['js_challenge_passed'] ?? 0);
            
            $todayKey = 'js_challenge:stats:' . date('Y-m-d');
            $todayStats = $this->redis->hgetall($todayKey);
            $stats['today_shown'] = (int)($todayStats['js_challenge_shown'] ?? 0);
            $stats['today_passed'] = (int)($todayStats['js_challenge_passed'] ?? 0);
            
            $iterator = null;
            $count = 0;
            do {
                $keys = $this->redis->scan($iterator, $this->redisPrefix . 'js_challenge:token:*', 100);
                if ($keys !== false) {
                    $count += count($keys);
                }
            } while ($iterator !== 0 && $iterator !== null);
            $stats['active_tokens'] = $count;
            
            if ($stats['total_shown'] > 0) {
                $stats['success_rate'] = round(($stats['total_passed'] / $stats['total_shown']) * 100, 1);
            }
            
            return $stats;
            
        } catch (Exception $e) {
            error_log("Error getting JS challenge stats: " . $e->getMessage());
            return [];
        }
    }
    
    /**
     * АДАПТИВНАЯ ЗАЩИТА v2.8.0
     * Определяет режим работы (нормальный/атака) на основе метрик
     * @return array ['mode' => 'normal'|'attack', 'reason' => string, 'metrics' => array]
     */
    private function detectAttackMode() {
        try {
            // Получаем текущие метрики за последнюю минуту
            $now = time();
            $oneMinuteAgo = $now - 60;
            
            // 1. Считаем RPS (requests per second)
            $rpmKey = 'stats:rpm:' . date('Y-m-d-H-i', $now);
            $currentRPM = (int)$this->redis->get($rpmKey);
            $currentRPS = round($currentRPM / 60, 2);
            
            // 2. Считаем провалы JS Challenge за последнюю минуту
            $failuresCount = 0;
            $iterator = null;
            do {
                $keys = $this->redis->scan($iterator, $this->trackingPrefix . 'js_challenge_failures:*', 100);
                if ($keys !== false && is_array($keys)) {
                    foreach ($keys as $key) {
                        $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                        $failures = (int)$this->redis->get($keyWithoutPrefix);
                        if ($failures > 0) {
                            $failuresCount += $failures;
                        }
                    }
                }
            } while ($iterator != 0);
            
            // 3. Считаем новые блокировки за последнюю минуту
            $blocksCount = 0;
            $iterator = null;
            do {
                $keys = $this->redis->scan($iterator, $this->redisPrefix . 'blocked:*', 100);
                if ($keys !== false && is_array($keys)) {
                    foreach ($keys as $key) {
                        $keyWithoutPrefix = str_replace($this->redisPrefix, '', $key);
                        $blockData = $this->redis->get($keyWithoutPrefix);
                        if ($blockData && is_array($blockData)) {
                            $blockedAt = $blockData['blocked_at'] ?? 0;
                            if ($blockedAt >= $oneMinuteAgo) {
                                $blocksCount++;
                            }
                        }
                    }
                }
            } while ($iterator != 0);
            
            $metrics = [
                'rps' => $currentRPS,
                'failures_per_minute' => $failuresCount,
                'blocks_per_minute' => $blocksCount,
                'timestamp' => $now
            ];
            
            // Проверяем критерии атаки
            $isAttack = false;
            $reasons = [];
            
            if ($currentRPS >= $this->jsChallengeSettings['attack_rps_threshold']) {
                $isAttack = true;
                $reasons[] = "High RPS: {$currentRPS} >= {$this->jsChallengeSettings['attack_rps_threshold']}";
            }
            
            if ($failuresCount >= $this->jsChallengeSettings['attack_failures_per_minute']) {
                $isAttack = true;
                $reasons[] = "High JS failures: {$failuresCount} >= {$this->jsChallengeSettings['attack_failures_per_minute']}";
            }
            
            if ($blocksCount >= $this->jsChallengeSettings['attack_blocks_per_minute']) {
                $isAttack = true;
                $reasons[] = "High blocks: {$blocksCount} >= {$this->jsChallengeSettings['attack_blocks_per_minute']}";
            }
            
            // Если атака, сохраняем время начала
            if ($isAttack) {
                $attackStartKey = 'adaptive:attack_start';
                if (!$this->redis->exists($attackStartKey)) {
                    $this->redis->set($attackStartKey, $now);
                    error_log("🚨 ADAPTIVE PROTECTION: ATTACK MODE ACTIVATED | " . implode(', ', $reasons));
                }
            } else {
                // Проверяем, была ли атака и закончилась ли она
                $attackStartKey = 'adaptive:attack_start';
                $attackStart = $this->redis->get($attackStartKey);
                
                if ($attackStart) {
                    // Атака была, проверяем сколько времени прошло с низким RPS
                    $lowRPSDuration = $now - $attackStart;
                    $recoveryDuration = $this->jsChallengeSettings['recovery_duration'];
                    
                    if ($currentRPS <= $this->jsChallengeSettings['recovery_rps_threshold'] && 
                        $lowRPSDuration >= $recoveryDuration) {
                        // Атака закончилась
                        $this->redis->del($attackStartKey);
                        error_log("✅ ADAPTIVE PROTECTION: NORMAL MODE RESTORED | Duration: {$lowRPSDuration}s");
                    } else {
                        // Атака ещё идёт (RPS снизился, но недостаточно долго)
                        $isAttack = true;
                        $reasons[] = "Recovery in progress ({$lowRPSDuration}/{$recoveryDuration}s)";
                    }
                }
            }
            
            return [
                'mode' => $isAttack ? 'attack' : 'normal',
                'reason' => implode('; ', $reasons),
                'metrics' => $metrics
            ];
            
        } catch (Exception $e) {
            error_log("Error detecting attack mode: " . $e->getMessage());
            return ['mode' => 'normal', 'reason' => 'error', 'metrics' => []];
        }
    }
    
    /**
     * АДАПТИВНАЯ ЗАЩИТА v2.8.0
     * Возвращает адаптивный порог провалов в зависимости от режима
     * @return int
     */
    private function getAdaptiveThreshold() {
        // Если адаптивная защита отключена, возвращаем статический порог
        if (!$this->jsChallengeSettings['adaptive_protection']) {
            return $this->jsChallengeSettings['failure_block_threshold'];
        }
        
        // Определяем режим
        $attackMode = $this->detectAttackMode();
        
        if ($attackMode['mode'] === 'attack') {
            // Режим атаки - агрессивный порог
            return $this->jsChallengeSettings['adaptive_threshold_attack'];
        } else {
            // Нормальный режим
            return $this->jsChallengeSettings['adaptive_threshold_normal'];
        }
    }
    
    /**
     * АДАПТИВНАЯ ЗАЩИТА v2.8.0
     * Публичный метод для получения статуса адаптивной защиты
     * @return array
     */
    public function getAdaptiveProtectionStatus() {
        if (!$this->jsChallengeSettings['adaptive_protection']) {
            return [
                'enabled' => false,
                'mode' => 'disabled',
                'threshold' => $this->jsChallengeSettings['failure_block_threshold'],
                'metrics' => []
            ];
        }
        
        $attackMode = $this->detectAttackMode();
        $currentThreshold = $this->getAdaptiveThreshold();
        
        return [
            'enabled' => true,
            'mode' => $attackMode['mode'],
            'threshold' => $currentThreshold,
            'reason' => $attackMode['reason'],
            'metrics' => $attackMode['metrics'],
            'settings' => [
                'normal_threshold' => $this->jsChallengeSettings['adaptive_threshold_normal'],
                'attack_threshold' => $this->jsChallengeSettings['adaptive_threshold_attack'],
                'attack_rps_threshold' => $this->jsChallengeSettings['attack_rps_threshold'],
                'attack_failures_per_minute' => $this->jsChallengeSettings['attack_failures_per_minute'],
                'attack_blocks_per_minute' => $this->jsChallengeSettings['attack_blocks_per_minute'],
                'recovery_rps_threshold' => $this->jsChallengeSettings['recovery_rps_threshold'],
                'recovery_duration' => $this->jsChallengeSettings['recovery_duration']
            ]
        ];
    }
    
    /**
     * Обновить настройки JS Challenge
     */
    public function updateJSChallengeSettings($newSettings) {
        $this->jsChallengeSettings = array_merge($this->jsChallengeSettings, $newSettings);
        error_log("JS Challenge settings updated: " . json_encode($newSettings));
    }
    
    /**
     * Получить настройки JS Challenge
     */
    public function getJSChallengeSettings() {
        return $this->jsChallengeSettings;
    }
    
    /**
     * Добавить URL в список исключений JS Challenge
     * 
     * @param string $urlPattern URL паттерн (поддерживает wildcard *)
     * @return bool True если добавлено успешно
     */
    public function addExcludedUrl($urlPattern) {
        if (!isset($this->jsChallengeSettings['excluded_urls'])) {
            $this->jsChallengeSettings['excluded_urls'] = [];
        }
        
        if (!in_array($urlPattern, $this->jsChallengeSettings['excluded_urls'])) {
            $this->jsChallengeSettings['excluded_urls'][] = $urlPattern;
            error_log("Added URL to JS Challenge exclusions: $urlPattern");
            return true;
        }
        
        return false;
    }
    
    /**
     * Удалить URL из списка исключений JS Challenge
     * 
     * @param string $urlPattern URL паттерн
     * @return bool True если удалено успешно
     */
    public function removeExcludedUrl($urlPattern) {
        if (!isset($this->jsChallengeSettings['excluded_urls'])) {
            return false;
        }
        
        $key = array_search($urlPattern, $this->jsChallengeSettings['excluded_urls']);
        if ($key !== false) {
            unset($this->jsChallengeSettings['excluded_urls'][$key]);
            $this->jsChallengeSettings['excluded_urls'] = array_values($this->jsChallengeSettings['excluded_urls']);
            error_log("Removed URL from JS Challenge exclusions: $urlPattern");
            return true;
        }
        
        return false;
    }
    
    /**
     * Получить список исключенных URL для JS Challenge
     * 
     * @return array Массив паттернов URL
     */
    public function getExcludedUrls() {
        return $this->jsChallengeSettings['excluded_urls'] ?? [];
    }
    
    /**
     * Установить список исключенных URL для JS Challenge
     * 
     * @param array $urlPatterns Массив паттернов URL
     */
    public function setExcludedUrls($urlPatterns) {
        $this->jsChallengeSettings['excluded_urls'] = array_values($urlPatterns);
        error_log("Set JS Challenge excluded URLs: " . json_encode($urlPatterns));
    }
    
    /**
     * Очистить список исключенных URL для JS Challenge
     */
    public function clearExcludedUrls() {
        $this->jsChallengeSettings['excluded_urls'] = [];
        error_log("Cleared JS Challenge excluded URLs");
    }
    
    /**
     * Проверить, исключен ли конкретный URL из JS Challenge
     * 
     * @param string $url URL для проверки (по умолчанию текущий)
     * @return bool True если URL исключен
     */
    public function isUrlExcluded($url = null) {
        if ($url === null) {
            $url = $_SERVER['REQUEST_URI'] ?? '/';
        }
        
        $excludedUrls = $this->jsChallengeSettings['excluded_urls'] ?? [];
        
        foreach ($excludedUrls as $pattern) {
            if ($this->matchUrlPattern($url, $pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    public function __destruct() {
        if ($this->redis) {
            try {
                $this->redis->close();
            } catch (Exception $e) {
                // Игнорируем ошибки при закрытии соединения
            }
        }
    }
}

} // end if (!class_exists('RedisBotProtectionNoSessions'))

// ========================================
// ИСПОЛЬЗОВАНИЕ ФИНАЛЬНОЙ ВЕРСИИ
// ========================================

// Защита от повторного выполнения при множественном include
if (!isset($GLOBALS['_bot_protection_initialized'])) {
    $GLOBALS['_bot_protection_initialized'] = true;

try {
    $protection = new RedisBotProtectionNoSessions(
        '127.0.0.1',    // Redis host
        6379,           // Redis port
        null,           // Redis password (если нужен)
        0               // Redis database
    );
    
    // Проверяем верификацию JS Challenge (обрабатываем AJAX запрос)
    if ($protection->verifyJSChallenge()) {
        exit; // Запрос обработан, выходим
    }
    
    $protection->protect();
    
    // ====== ПРИМЕРЫ АДМИНИСТРИРОВАНИЯ ======
    
    // Получить общую статистику
    // $stats = $protection->getStats();
    // echo "Заблокировано IP: " . $stats['blocked_ips'] . "\n";
    // echo "Нарушений rate limit: " . $stats['rate_limit_violations'] . "\n";
    // echo "Активных отслеживаний: " . $stats['tracking_records'] . "\n";
    
    // Получить топ нарушителей rate limit
    // $violators = $protection->getTopRateLimitViolators(10);
    // foreach ($violators as $v) {
    //     echo "Нарушений: " . $v['violations'] . " | ";
    //     echo "Запросов/мин: " . $v['requests_1min'] . " | ";
    //     echo "Последний: " . $v['last_request'] . "\n";
    // }
    
    // Проверить статус конкретного IP
    // $ip = '1.2.3.4';
    // $rateLimitStats = $protection->getRateLimitStats($ip);
    // print_r($rateLimitStats);
    // 
    // $blockInfo = $protection->getBlockedIPInfo($ip);
    // print_r($blockInfo);
    
    // Разблокировать IP и сбросить все данные
    // $protection->unblockIP('1.2.3.4');
    // $protection->resetRateLimit('1.2.3.4');
    // $protection->unblockUserHash(); // текущий пользователь
    
    // Настроить лимиты под ваш сайт
    // $protection->updateRateLimitSettings([
    //     'max_requests_per_minute' => 120,  // Более мягкий лимит для крупных сайтов
    //     'max_requests_per_5min' => 400,
    //     'burst_threshold' => 30,            // Увеличить порог всплесков
    //     'ua_change_threshold' => 3          // Строже к смене UA
    // ]);
    
    // Настроить защиту от переполнения Redis
    // $protection->updateGlobalProtectionSettings([
    //     'cleanup_threshold' => 10000,       // Для крупных сайтов
    //     'cleanup_batch_size' => 200,        // Удалять больше за раз
    //     'cleanup_probability' => 100,       // Проверять реже (1%)
    //     'max_cleanup_time_ms' => 100        // Больше времени на очистку
    // ]);
    
    // Настроить rDNS rate limiting
    // $protection->updateRDNSSettings([
    //     'max_rdns_per_minute' => 120,       // Больше проверок для крупных сайтов
    //     'rdns_cache_ttl' => 3600,           // Кеш на 1 час
    //     'rdns_negative_cache_ttl' => 600,   // Негативный кеш 10 минут
    //     'rdns_on_limit_action' => 'skip'    // 'skip' или 'block'
    // ]);
    
    // Проверить статистику rDNS
    // $rdnsStats = $protection->getRDNSRateLimitStats();
    // echo "rDNS запросов в текущую минуту: " . $rdnsStats['current_minute_requests'] . "/" . $rdnsStats['limit_per_minute'] . "\n";
    // echo "Записей в кеше: " . $rdnsStats['cache_entries'] . "\n";
    // echo "Верифицировано: " . $rdnsStats['verified_in_cache'] . "\n";
    // if ($rdnsStats['limit_reached']) {
    //     echo "ВНИМАНИЕ: Лимит rDNS достигнут!\n";
    // }
    
    // Очистить кеш rDNS (если нужно пересоздать)
    // $cleared = $protection->clearRDNSCache();
    // echo "Очищено записей rDNS кеша: $cleared\n";
    
    // Сбросить счетчики rDNS rate limit
    // $protection->resetRDNSRateLimit();
    
    // Проверить состояние памяти Redis
    // $memInfo = $protection->getRedisMemoryInfo();
    // echo "Используемая память: " . $memInfo['used_memory'] . "\n";
    // echo "Отслеживаемых IP: " . $memInfo['tracked_ips_count'] . "\n";
    // echo "Нужна очистка: " . ($memInfo['cleanup_needed'] ? 'ДА' : 'НЕТ') . "\n";
    
    // Принудительная очистка Redis
    // $cleaned = $protection->forceCleanup();  // Обычная очистка
    // echo "Очищено записей: $cleaned\n";
    // 
    // $cleaned = $protection->forceCleanup(true);  // Агрессивная (все >1 часа)
    // echo "Агрессивно очищено: $cleaned\n";
    
    // Настроить детекцию медленных ботов
    // $protection->updateSlowBotSettings([
    //     'min_requests_for_analysis' => 5,
    //     'long_session_hours' => 3
    // ]);
    
    // Диагностика текущего пользователя
    // $diagnosis = $protection->diagnoseUserHash();
    // echo "Hash: " . $diagnosis['stable_hash'] . "\n";
    // echo "IP: " . $diagnosis['ip'] . "\n";
    // echo "Устройство: " . $diagnosis['device_type'] . "\n";
    // echo "Браузер: " . $diagnosis['browser']['name'] . " " . $diagnosis['browser']['version'] . "\n";
    
    // Получить информацию о хеше пользователя
    // $hashInfo = $protection->getUserHashInfo();
    // print_r($hashInfo);
    
    // Ручная очистка Redis
    // $cleaned = $protection->cleanup(true);  // Полная очистка
    // echo "Очищено записей: $cleaned\n";
    // 
    // $deepCleaned = $protection->deepCleanup();  // Глубокая очистка
    // echo "Глубоко очищено: $deepCleaned\n";
    
    // ПРИМЕРЫ ТЕСТИРОВАНИЯ rDNS (раскомментируйте для тестов):
    // echo "\n=== ТЕСТИРОВАНИЕ ПОИСКОВИКОВ ===\n\n";
    // $protection->testRDNS('66.249.66.1', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)');
    // echo "\n" . str_repeat("=", 50) . "\n\n";
    // $protection->testRDNS('40.77.167.181', 'Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)');
    // echo "\n" . str_repeat("=", 50) . "\n\n";
    // $protection->testRDNS('1.2.3.4', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)');
    
} catch (Exception $e) {
    error_log("CRITICAL: Bot protection failed - " . $e->getMessage());
    // В случае ошибки Redis - продолжаем работу без защиты
}

} // end if (!isset($GLOBALS['_bot_protection_initialized']))

/*
====================================================================
ЧТО ДЕЛАЕТ НОВАЯ ЗАЩИТА
====================================================================

1. RATE LIMITING - ограничивает количество запросов:
   ✔ 60 запросов в минуту (настраивается)
   ✔ 200 запросов за 5 минут
   ✔ 1000 запросов в час
   ✔ При превышении - прогрессивная блокировка

2. ДЕТЕКЦИЯ СМЕНЫ USER-AGENT:
   ✔ Блокирует IP, которые часто меняют UA
   ✔ Порог: 5 различных UA за 5 минут
   ✔ Помогает против ротации User-Agent

3. BURST DETECTION (всплески активности):
   ✔ Обнаруживает 20+ запросов за 10 секунд
   ✔ Немедленная блокировка при детекции
   ✔ Защита от flood-атак

4. ПРОГРЕССИВНАЯ БЛОКИРОВКА:
   ✔ 1-е нарушение: 30 минут блокировки
   ✔ 2-е нарушение: 1 час
   ✔ 3+ нарушения: 2+ часа (растет с каждым разом)
   ✔ История блокировок хранится 7 дней

5. ДЕТЕКЦИЯ МЕДЛЕННЫХ БОТОВ:
   ✔ Обнаруживает ботов с низкой активностью
   ✔ Анализирует паттерны долгосрочного поведения
   ✔ Регулярность запросов, разнообразие страниц

6. РАСШИРЕННОЕ ОТСЛЕЖИВАНИЕ:
   ✔ Автоматически включается для подозрительных
   ✔ Более строгий анализ поведения
   ✔ 24 часа детального мониторинга

7. ВЕРИФИКАЦИЯ ПОИСКОВИКОВ:
   ✔ Проверка Google, Bing, Yandex и других
   ✔ rDNS верификация (обратный + прямой DNS)
   ✔ Кеширование результатов проверки

8. RATE LIMITING ДЛЯ rDNS:
   ✔ Ограничение rDNS проверок (60/минуту по умолчанию)
   ✔ Защита от перегрузки DNS серверов
   ✔ Умное кеширование (30 мин позитив, 5 мин негатив)
   ✔ Настраиваемое действие при превышении (skip/block)
   ✔ Статистика использования rDNS

9. ЗАЩИТА ОТ ПЕРЕПОЛНЕНИЯ REDIS:
   ✔ Автоматическая очистка старых записей
   ✔ Вероятностная проверка (2% запросов)
   ✔ SCAN вместо KEYS (не блокирует Redis)
   ✔ Максимум 50ms на одну очистку
   ✔ Счетчик tracked IP для быстрой проверки
   ✔ Умное удаление: старые + неактивные первыми

====================================================================
РЕКОМЕНДАЦИИ ПО НАСТРОЙКЕ
====================================================================

ДЛЯ НЕБОЛЬШИХ САЙТОВ (<1000 посетителей/день):
   - Оставьте настройки по умолчанию
   - max_requests_per_minute: 60
   - burst_threshold: 20

ДЛЯ СРЕДНИХ САЙТОВ (1000-10000 посетителей/день):
   $protection->updateRateLimitSettings([
       'max_requests_per_minute' => 90,
       'max_requests_per_5min' => 300,
       'burst_threshold' => 30
   ]);

ДЛЯ КРУПНЫХ САЙТОВ (> 10000 посетителей/день):
   $protection->updateRateLimitSettings([
       'max_requests_per_minute' => 120,
       'max_requests_per_5min' => 500,
       'max_requests_per_hour' => 2000,
       'burst_threshold' => 40
   ]);
   
   Регулярно проверяйте:
   - getTopRateLimitViolators() для мониторинга
   - getStats() для общей статистики

ДЛЯ API И ВЫСОКОНАГРУЖЕННЫХ ПРИЛОЖЕНИЙ:
   $protection->updateRateLimitSettings([
       'max_requests_per_minute' => 180,
       'max_requests_per_5min' => 800,
       'burst_threshold' => 50,
       'ua_change_threshold' => 10  // API могут менять UA
   ]);

СТРОГИЙ РЕЖИМ (максимальная защита):
   $protection->updateRateLimitSettings([
       'max_requests_per_minute' => 30,
       'max_requests_per_5min' => 100,
       'burst_threshold' => 10,
       'ua_change_threshold' => 3
   ]);

НАСТРОЙКИ rDNS RATE LIMITING:

ДЛЯ НЕБОЛЬШИХ САЙТОВ (<1000 посетителей/день):
   // Оставьте по умолчанию:
   // max_rdns_per_minute: 60
   // rdns_cache_ttl: 1800 (30 минут)

ДЛЯ СРЕДНИХ САЙТОВ (1000-10000 посетителей/день):
   $protection->updateRDNSSettings([
       'max_rdns_per_minute' => 120,
       'rdns_cache_ttl' => 3600,           // 1 час
       'rdns_negative_cache_ttl' => 600    // 10 минут
   ]);

ДЛЯ КРУПНЫХ САЙТОВ (>10000 посетителей/день):
   $protection->updateRDNSSettings([
       'max_rdns_per_minute' => 200,
       'rdns_cache_ttl' => 7200,           // 2 часа
       'rdns_negative_cache_ttl' => 900,   // 15 минут
       'rdns_on_limit_action' => 'skip'    // Не блокировать при превышении
   ]);

ДЛЯ ОЧЕНЬ КРУПНЫХ (>100000 посетителей/день):
   $protection->updateRDNSSettings([
       'max_rdns_per_minute' => 300,       // Или выше
       'rdns_cache_ttl' => 14400,          // 4 часа
       'rdns_negative_cache_ttl' => 1800,  // 30 минут
       'rdns_on_limit_action' => 'skip'
   ]);
   
   // ВАЖНО: Рассмотрите отдельный DNS кеш сервер (dnsmasq/unbound)

ЕСЛИ МНОГО ПОИСКОВЫХ БОТОВ:
   $protection->updateRDNSSettings([
       'max_rdns_per_minute' => 500,
       'rdns_cache_ttl' => 86400,          // 24 часа (боты стабильны)
       'rdns_negative_cache_ttl' => 3600
   ]);

НАСТРОЙКИ ЗАЩИТЫ ОТ ПЕРЕПОЛНЕНИЯ:

ДЛЯ НЕБОЛЬШИХ САЙТОВ (<1000 посетителей/день):
   // Оставьте по умолчанию:
   // cleanup_threshold: 5000
   // cleanup_probability: 50 (2% запросов)

ДЛЯ СРЕДНИХ САЙТОВ (1000-10000 посетителей/день):
   $protection->updateGlobalProtectionSettings([
       'cleanup_threshold' => 10000,
       'cleanup_batch_size' => 150,
       'cleanup_probability' => 75  // 1.3% запросов
   ]);

ДЛЯ КРУПНЫХ САЙТОВ (>10000 посетителей/день):
   $protection->updateGlobalProtectionSettings([
       'cleanup_threshold' => 20000,
       'cleanup_batch_size' => 200,
       'cleanup_probability' => 100, // 1% запросов
       'max_cleanup_time_ms' => 100  // Больше времени на очистку
   ]);

ДЛЯ ОЧЕНЬ КРУПНЫХ (>100000 посетителей/день):
   $protection->updateGlobalProtectionSettings([
       'cleanup_threshold' => 50000,
       'cleanup_batch_size' => 500,
       'cleanup_probability' => 200, // 0.5% запросов
       'max_cleanup_time_ms' => 200
   ]);
   
   // + Рассмотрите выделенный Redis сервер
   // + Настройте Redis persistence (AOF/RDB)

====================================================================
МОНИТОРИНГ И ОТЛАДКА
====================================================================

Регулярно проверяйте логи:
   tail -f /var/log/php_errors.log | grep "RATE LIMIT"
   tail -f /var/log/php_errors.log | grep "Bot blocked"
   tail -f /var/log/php_errors.log | grep "Redis cleanup"
   tail -f /var/log/php_errors.log | grep "rDNS rate limit"

Проверка статистики (добавьте в cron каждый час):
   $stats = $protection->getStats();
   if ($stats['rate_limit_violations'] > 100) {
       // Отправить уведомление администратору
   }

Мониторинг rDNS (каждый час):
   $rdnsStats = $protection->getRDNSRateLimitStats();
   if ($rdnsStats['limit_reached']) {
       error_log("WARNING: rDNS rate limit reached! Current: " . 
                $rdnsStats['current_minute_requests'] . "/" . 
                $rdnsStats['limit_per_minute']);
       
       // Опционально: увеличить лимит или очистить старый кеш
       if ($rdnsStats['cache_entries'] > 10000) {
           $protection->clearRDNSCache();
       }
   }
   
   // Логировать статистику
   error_log("rDNS Stats: " . 
            "Current: {$rdnsStats['current_minute_requests']}, " .
            "Cache: {$rdnsStats['cache_entries']}, " .
            "Verified: {$rdnsStats['verified_in_cache']}");

Проверка памяти Redis (каждые 30 минут):
   $memInfo = $protection->getRedisMemoryInfo();
   if ($memInfo['cleanup_needed']) {
       error_log("WARNING: Redis cleanup needed! Tracked IPs: " . 
                $memInfo['tracked_ips_count']);
       // Опционально: принудительная очистка
       $protection->forceCleanup();
   }

Еженедельная очистка (добавьте в cron):
   $protection->deepCleanup();
   
Ежедневная агрессивная очистка (для крупных сайтов):
   $cleaned = $protection->forceCleanup(true);
   error_log("Daily aggressive cleanup: removed $cleaned records");

Мониторинг производительности:
   // Проверяйте время очистки в логах:
   // "Redis cleanup: removed 150 tracked IPs (approx 45.23ms)"
   
   // Если время >100ms регулярно:
   $protection->updateGlobalProtectionSettings([
       'cleanup_batch_size' => 50,  // Уменьшите размер батча
       'max_cleanup_time_ms' => 80  // Уменьшите лимит времени
   ]);

====================================================================
TROUBLESHOOTING
====================================================================

Если блокируются легитимные пользователи:
1. Проверьте логи: grep "RATE LIMIT BLOCK" /var/log/php_errors.log
2. Увеличьте лимиты для вашего типа сайта
3. Разблокируйте конкретный IP: $protection->unblockIP('x.x.x.x')
4. Сбросьте счетчики: $protection->resetRateLimit('x.x.x.x')

Если пропускаются боты:
1. Уменьшите пороги в настройках
2. Проверьте логи на паттерны: $protection->getBlockedIPInfo('x.x.x.x')
3. Добавьте в список подозрительных UA в методе isSuspiciousUserAgent()

Проблемы с rDNS верификацией:
1. Проверьте лимит: $rdnsStats = $protection->getRDNSRateLimitStats()
2. Если лимит часто достигается:
   $protection->updateRDNSSettings([
       'max_rdns_per_minute' => 200,  // Увеличить лимит
       'rdns_cache_ttl' => 7200       // Увеличить кеш
   ]);
3. Очистить старый кеш: $protection->clearRDNSCache()
4. Проверить DNS сервер: dig -x <IP> (должен работать быстро)
5. Если DNS медленный - рассмотрите локальный DNS кеш (dnsmasq)
6. Тестировать конкретный IP: $protection->testRDNS('66.249.66.1', 'Googlebot')

Блокируются легитимные поисковики:
1. Проверьте что rDNS не превышает лимит
2. Убедитесь что rdns_on_limit_action = 'skip' (не 'block')
3. Увеличьте кеш TTL для верифицированных ботов:
   $protection->updateRDNSSettings(['rdns_cache_ttl' => 86400]);
4. Проверьте логи: grep "rDNS" /var/log/php_errors.log

Если Redis падает или недоступен:
- Скрипт продолжит работу БЕЗ защиты
- Проверьте подключение к Redis
- Убедитесь что Redis запущен: redis-cli ping

====================================================================
БЕЗОПАСНОСТЬ
====================================================================

ВАЖНО: Измените секретный ключ!
   private $secretKey = 'your_secret_key_here_change_this12345!@#$';
   
Используйте сложный уникальный ключ для вашего сайта.

ВАЖНО: Настройте Redis правильно!
   - Используйте пароль для Redis
   - Ограничьте доступ к Redis по IP
   - Используйте отдельную БД для bot protection

ВАЖНО: Оптимизируйте DNS для rDNS проверок!
   - Установите локальный DNS кеш (dnsmasq, unbound)
   - Настройте systemd-resolved правильно
   - Проверьте /etc/resolv.conf на корректность
   - Увеличьте TTL кеша для rDNS результатов
   
МОНИТОРИНГ rDNS:
   # Проверить сколько rDNS запросов в минуту
   watch -n 5 'redis-cli --scan --pattern "bot_protection:rdns:ratelimit:*" | xargs redis-cli mget'
   
   # Размер rDNS кеша
   redis-cli --scan --pattern "bot_protection:rdns:cache:*" | wc -l
   
   # Производительность DNS
   time dig -x 66.249.66.1  # Должно быть <50ms

====================================================================
МИГРАЦИЯ НА ВЕРСИЮ 2.3 (оптимизация памяти)
====================================================================

После обновления до версии 2.3 ОБЯЗАТЕЛЬНО запустите миграцию
для удаления старых rate limit ключей:

   // Запустить ОДИН раз после обновления!
   $protection = new RedisBotProtectionNoSessions();
   $deleted = $protection->migrateFromOldRateLimitKeys();
   echo "Удалено старых ключей: $deleted\n";

Или через CLI:
   php -r "
   require '/var/www/your-site/bot_protection/inline_check.php';
   \$p = new RedisBotProtectionNoSessions();
   echo 'Deleted: ' . \$p->migrateFromOldRateLimitKeys() . PHP_EOL;
   "

ДИАГНОСТИКА ИСПОЛЬЗОВАНИЯ КЛЮЧЕЙ:

   $stats = $protection->getKeyStats();
   print_r($stats);
   
   // Покажет:
   // [tracking_ip] => 2360      - основной трекинг
   // [rate_limit] => 2400       - rate limit (v2.3: 1 на IP)
   // [global_rate_limit] => 100 - глобальный rate limit
   // [blocked] => 50            - заблокированные
   // [rdns] => 200              - кеш rDNS
   // [user_hash] => 500         - user hash трекинг
   // [extended] => 100          - расширенный трекинг
   // [total] => 5710            - всего ключей

ОЖИДАЕМОЕ СОКРАЩЕНИЕ КЛЮЧЕЙ ПОСЛЕ МИГРАЦИИ:

   Было (v2.1-2.2):
   - 2,360 IP × 5-7 ключей = 12,000-16,000 ключей
   
   Стало (v2.3):
   - 2,360 IP × 2-3 ключа = 4,700-7,000 ключей
   
   Экономия: ~50-60% ключей и памяти!

====================================================================
*/
?>
